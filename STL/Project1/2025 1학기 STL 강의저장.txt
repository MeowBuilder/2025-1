
==========================================
저장한 시간: 2025-03-10 오후 7:03:39 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 3월 10일 월요일				(1주 2일)
//-----------------------------------------------------------
// 한학기 강의 자료를 저장할 save기능
//-----------------------------------------------------------

#include <iostream>
#include <string>
#include <fstream>
#include <algorithm>
#include <filesystem>
#include <chrono>

void save( std::string_view );

//-----------------------------------------------------------
int main()
//-----------------------------------------------------------
{
	std::cout << "2025년 1학기 STL" << std::endl;

	save("메인.cpp");
}

//-----------------------------------------------------------
void save( std::string_view filename )
//-----------------------------------------------------------
{
	// 1.인자로 전달된 파일을 읽기 모드로 연다.
	std::ifstream in{ filename.data()}; // RAII

	if ( not in )
	{
		std::cout << filename << "을 열 수 없습니다." << std::endl;
		exit( 20250310 );
	}

	// 저장했다는 것을 화면에 표시
	std::cout << filename << "(" << std::filesystem::file_size(filename) << " bytes) 저장하였습니다." << std::endl;

	// 2.쓰기모드로 저장할 파일을 (덧붙이기 모드로) 연다
	std::ofstream out{ "2025 1학기 STL 강의저장.txt", std::ios::app }; // { } <- uniform initializer

	

	// 시간 기록
	auto now = std::chrono::system_clock::now(); // epoch로 부터 경과된 tick 수를 얻는다.
	auto utc = std::chrono::system_clock::to_time_t(now); // UTC
	auto lt = std::localtime(&utc); // 지역시간(한국)으로 변경

	auto old = out.imbue(std::locale("Ko-KR")); // 스트림의 지역을 변경

	out << "\n" << "\n";
	out << "======================================================================" << "\n";
	out << "저장한 시간: " << std::put_time(lt, "%c %A") << "\n";
	out << "======================================================================" << "\n";
	out << "\n";

	out.imbue(old); // 변경 이전으로 복원

	// 3.파일을 읽어서 저장할 파일에 덧붙인다.
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}

==========================================
저장한 시간: 2025-03-13 오후 5:38:06 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 3월 13일 목요일				(2주 1일)
//-----------------------------------------------------------
// save기능을 파일로 분리한다.
//-----------------------------------------------------------

#include <iostream>
#include "save.h"

int main()
{
	std::cout << "2025년 1학기 STL" << std::endl;

	save("메인.cpp");
	save("save.h");
	save("save.cpp");
}

==========================================
저장한 시간: 2025-03-13 오후 5:38:06 목요일
==========================================

//----------------------------------------------------
// save.h
//											2025.03.13
//----------------------------------------------------

#pragma once

void save(std::string_view);

==========================================
저장한 시간: 2025-03-13 오후 5:38:06 목요일
==========================================

//----------------------------------------------------
// save.cpp - 한 학기 강의를 잘 저장하는 함수
//											2025.03.13
//----------------------------------------------------

#include <string_view>
#include <iostream>
#include <fstream>
#include <filesystem>
#include <chrono>
#include "save.h"

void save(std::string_view filename)
{
	// 1.인자로 전달된 파일을 읽기 모드로 연다.
	std::ifstream in{ filename.data() }; // RAII

	if (not in)
	{
		std::cout << filename << "을 열 수 없습니다." << std::endl;
		exit(20250310);
	}

	// 저장했다는 것을 화면에 표시
	std::cout << filename << "(" << std::filesystem::file_size(filename) << " bytes) 저장하였습니다." << std::endl;

	// 2.쓰기모드로 저장할 파일을 (덧붙이기 모드로) 연다
	std::ofstream out{ "2025 1학기 STL 강의저장.txt", std::ios::app }; // { } <- uniform initializer



	// 시간 기록
	auto now = std::chrono::system_clock::now(); // epoch로 부터 경과된 tick 수를 얻는다.
	auto utc = std::chrono::system_clock::to_time_t(now); // UTC
	auto lt = std::localtime(&utc); // 지역시간(한국)으로 변경

	auto old = out.imbue(std::locale("Ko-KR")); // 스트림의 지역을 변경

	out << "\n" << "\n";
	out << "==========================================" << "\n";
	out << "저장한 시간: " << std::put_time(lt, "%c %A") << "\n";
	out << "==========================================" << "\n";
	out << "\n";

	out.imbue(old); // 변경 이전으로 복원

	// 3.파일을 읽어서 저장할 파일에 덧붙인다.
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}

==========================================
저장한 시간: 2025-03-13 오후 7:02:21 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 3월 13일 목요일				(2주 1일)
//-----------------------------------------------------------
// Generic Programming의 핵심 키워드 - template
//-----------------------------------------------------------

#include <algorithm>
#include <iostream>
#include "save.h"

// [문제] main을 변경하지 말고 의도대로 실행되게 코딩하라. 단 Dog는 Class이다.

class Dog
{
public:
	Dog() = default;
	Dog(int dognumber) : dognum{ dognumber } {};

	friend std::ostream& operator<< (std::ostream& os, const Dog& obj) {
		os << obj.dognum;
		return os;
	}

private:
	int dognum;
};

//템플릿은 선언과 정의를 동시에 해야 한다.
template <class T>
void change(T& a, T& b) {
	T temp{ a };
	a = b;
	b = temp;
}

int main()
{
	{
		Dog a{ 1 }, b{ 2 };
		change(a, b);
		// 어떤 함수가 실행되는 것인가
		// 1. change(Dog, Dog);
		// 2. change(Dog&, Dog&);
		// 3. 컴파일러인 내가 만들 순 없을까?
		std::cout << a << ", " << b << std::endl;
	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << ", " << b << std::endl;
	}

	
	save("메인.cpp");
}

==========================================
저장한 시간: 2025-03-17 오후 6:45:14 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 3월 17일 월요일				(2주 2일)
//-----------------------------------------------------------
// 많은 수의 자료를 다루기 - int
//-----------------------------------------------------------

#include <iostream>
#include "save.h"

#include <random>
#include <print>
#include <array>
#include <algorithm>

std::mt19937_64 dre(std::random_device{}());
std::uniform_int_distribution<int> uid{ 0, 1000000000 };

int main()
{
	std::array<int, 1000> arr; // T[N] -> array<T,N>

	std::generate(arr.begin(), arr.end(), [] { return uid(dre); }); // begin부터 end까지 3번째 인수의 함수의 리턴값으로 초기화

	std::print("가장 큰 값은 {:10}이다.\n", *std::max_element(arr.begin(), arr.end()));

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-03-17 오후 6:59:56 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 3월 17일 월요일				(2주 2일)
//-----------------------------------------------------------
// 많은 수의 자료를 다루기 - int
//-----------------------------------------------------------

#include <iostream>
#include "save.h"

#include <random>
#include <fstream>
#include <print>

std::mt19937_64 dre(std::random_device{}());
std::uniform_int_distribution<int> uid{ 0, 10000000 };

// [문제] 랜덤 int값 1000개 파일 "int 1000개.txt"에 저장하라.
// 저장한 파일은 사람이 읽을 수 있어야 한다. 나중에 파일에서 int값을 읽어 올 수 있어야 한다.

int main()
{
	std::ofstream out{ "int 1000개.txt" };

	int cnt{ 0 };
	for (int i = 0; i < 1000; i++)
	{
		std::print(out, "{:8}", uid(dre));
		if (0 == ++cnt % 10)
		{
			out << std::endl;
		}
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-03-20 오후 6:06:09 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 3월 20일 월요일				(3주 1일)
//-----------------------------------------------------------
// 많은 수의 자료를 다루기 - int를 메모리 크기 그대로 저장
//-----------------------------------------------------------

#include <iostream>
#include <array>
#include <numeric>
#include <fstream>
#include "save.h"

// [상황] int 1000개를 메모리 크기 그대로 저장하고 싶다.
// 파일 "int 1000개를 메모리 그대로.txt"에 저장한다.
// 이런 상황에는 해당 stream의 저수준 입출력 함수(read/write)를 사용한다.

int main()
{
	std::array<int, 1000> arr;
	std::iota(arr.begin(), arr.end(), 1);

	std::ofstream out{ "int 1000개를 메모리 그대로.txt" };
	out.write( (char*)arr.data(), arr.size() * sizeof(int) );

	for (int num : arr) {
		std::cout << num << " ";
	}
	std::cout << std::endl;

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-03-20 오후 6:24:20 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 3월 20일 월요일				(3주 1일)
//-----------------------------------------------------------
// 많은 수의 자료를 다루기 - int를 메모리 크기 그대로 저장
//-----------------------------------------------------------

#include <iostream>
#include <array>
#include <numeric>
#include <fstream>
#include "save.h"

// [상황] int 1000개를 메모리 크기 그대로 저장하고 싶다.
// 파일 "int 1000개를 메모리 그대로.txt"에 저장한다.
// 이런 상황에는 해당 stream의 저수준 입출력 함수(read/write)를 사용한다.

int main()
{
	std::array<int, 1000> arr;
	arr.fill(1);
	//std::iota(arr.begin(), arr.end(), 1);

	std::ofstream out{ "int 1000개를 메모리 그대로.txt" , std::ios::binary };

	out.write((char*)arr.data(), arr.size() * sizeof(decltype(arr)::value_type));

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-03-20 오후 6:32:08 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 3월 20일 월요일				(3주 1일)
//-----------------------------------------------------------
// 많은 수의 자료를 다루기 - int를 메모리 크기 그대로 저장
//-----------------------------------------------------------

#include <iostream>
#include <array>
#include <fstream>
#include <random>
#include "save.h"

// 진짜 랜덤값(non deterministic value)을 갖는 int 10만개를
// 파일 "진짜 랜덤 10만개"에 저장하였다.
// 파일을 binary mode로 열었고 write함수를 사용하여 메모리 그대로 저장하였다.


int main()
{
	std::array<int, 10'0000> arr;

	std::generate(arr.begin(), arr.end(), [] { std::random_device rd; return rd(); });

	std::ofstream out{ "진짜 랜덤 10만개" , std::ios::binary };

	out.write((char*)arr.data(), arr.size() * sizeof(decltype(arr)::value_type));

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-03-20 오후 6:53:50 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 3월 20일 월요일				(3주 1일)
//-----------------------------------------------------------
// 많은 수의 자료를 다루기 - int를 메모리 크기 그대로 저장
//-----------------------------------------------------------

#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include "save.h"

// [문제] "진짜 랜덤 10만개"에는 int값이 기록되어 있다.
// 파일은 binary mode로 열었고 파일의 write 함수로 메모리 그대로 기록하였다.
// 파일에 있는 모든 int 값을 메모리에 저장하라.
// 가장 작은 값과 가장 큰 값을 찾아 화면에 출력하라.

int main()
{
	std::ifstream in{ "진짜 랜덤 10만개",std::ios::binary };
	if (not in)
	{
		std::cout << "진짜 랜덤 10만개을 열 수 없습니다." << std::endl;
		exit(4444);
	}

	int num{ 0 };
	int count{ 0 };
	while (in.read((char*)&num, sizeof(int))) {
		++count;
	}

	std::cout << "int의 개수 : " << count << "개" << std::endl;
	
	// int 개수 확인

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-03-20 오후 7:02:10 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 3월 20일 월요일				(3주 1일)
//-----------------------------------------------------------
// 많은 수의 자료를 다루기 - int를 메모리 크기 그대로 저장
//-----------------------------------------------------------

#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"

// [문제] "진짜 랜덤 10만개"에는 int값 10만개가 기록되어 있다.
// 파일은 binary mode로 열었고 파일의 write 함수로 메모리 그대로 기록하였다.
// 파일에 있는 모든 int 값을 메모리에 저장하라.
// 가장 작은 값과 가장 큰 값을 찾아 화면에 출력하라.

int main()
{
	std::ifstream in{ "진짜 랜덤 10만개",std::ios::binary };

	std::array<int, 10'0000> arr;

	in.read((char*)arr.data(), sizeof(int) * arr.size());

	std::pair minmax = std::minmax_element(arr.begin(), arr.end());

	std::cout << "최솟값 : " << *minmax.first << std::endl;
	std::cout << "최댓값 : " << *minmax.second << std::endl;

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-03-24 오후 5:41:08 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 3월 24일 월요일				(3주 2일)
//-----------------------------------------------------------
// 많은 수의 자료를 다루기 - int를 메모리 크기 그대로 저장
//-----------------------------------------------------------

#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"

// [문제] "진짜 랜덤 10만개"에는 int값 10만개가 기록되어 있다.
// 파일은 binary mode로 열었고 파일의 write 함수로 메모리 그대로 기록하였다.
// 파일에 있는 모든 int 값을 메모리에 저장하라.
// 가장 작은 값과 가장 큰 값을 찾아 화면에 출력하라.

int main()
{
	std::ifstream in{ "진짜 랜덤 10만개",std::ios::binary };

	std::array<int, 10'0000> arr;

	in.read((char*)arr.data(), sizeof(int) * arr.size());

	// structured binding
	auto [최솟값의위치, 최댓값의위치] = std::minmax_element(arr.begin(), arr.end());
	std::cout << "최솟값 : " << *최솟값의위치<< std::endl;
	std::cout << "최댓값 : " << *최댓값의위치 << std::endl;

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-03-24 오후 6:11:38 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 3월 24일 월요일				(3주 2일)
//-----------------------------------------------------------
// 많은 수의 자료를 다루기 - Dog를 읽고 쓸 수 있게
//-----------------------------------------------------------

#include <iostream>
#include <string>
#include <random>
#include <print>
#include <fstream>

#include "save.h"

std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a','z' };

class Dog {
public:
	Dog() : id{ ++sid } {
		for (int i = 0; i < 15; i++) {
			name += uid(dre);
		}
	}

	void show() const {
		std::println("[{:8}] - {}", id, name);
	}
private:
	std::string name{};
	int id;

	static int sid; //scope:local, life-time:global
};

int Dog::sid{};

// Dog객체 10만개를 "Dog 10만 마리"에 저장하였다.
// 파일은 binary mode로 열었고 Dog객체는 파일의 write함수를 사용하여 메모리 그대로 저장하였다.

int main()
{
	std::ofstream out{ "Dog 10만 마리",std::ios::binary };

	for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		out.write((char*)&dog, sizeof(Dog));
	}
	

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-03-24 오후 6:39:40 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 3월 24일 월요일				(3주 2일)
//-----------------------------------------------------------
// 많은 수의 자료를 다루기 - Dog를 읽고 쓸 수 있게
//-----------------------------------------------------------

#include <iostream>
#include <string>
#include <fstream>
#include <array>

#include "save.h"

// "Dog 10만 마리"에는 Dog객체 10만개가 저장되어 있다.
// 파일은 binary mode로 열었고 write를 사용하여 메모리 그대로 저장하였다.
// Dog 객체 10만개를 메모리에 모두 저장하라.
// 제일 마지막 객체의 정보를 화면에 cout으로 출력하라

class Dog{
private:
	std::string name{};
	int id{};

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " - " << dog.name;
	}
};

std::array < Dog, 10'0000> dogs;

int main()
{
	std::ifstream in{ "Dog 10만 마리" ,std::ios::binary };
	if (not in) return 4444;

	in.read((char*)dogs.data(), sizeof(Dog) * dogs.size());

	std::cout << dogs.back() << std::endl;

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-03-24 오후 6:45:34 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 3월 24일 월요일				(3주 2일)
//-----------------------------------------------------------
// 많은 수의 자료를 다루기 - Dog를 읽고 쓸 수 있게
//-----------------------------------------------------------

#include <iostream>
#include <string>
#include <fstream>
#include <array>

#include "save.h"

// "Dog 10만 마리"에는 Dog객체 10만개가 저장되어 있다.
// 파일은 binary mode로 열었고 write를 사용하여 메모리 그대로 저장하였다.
// Dog 객체 10만개를 메모리에 모두 저장하라.
// 모든 객체의 정보를 화면에 cout으로 출력하라

class Dog{
private:
	std::string name{};
	int id{};

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " - " << dog.name;
	}
};

std::array < Dog, 10'0000> dogs;

int main()
{
	std::ifstream in{ "Dog 10만 마리" ,std::ios::binary };
	if (not in) return 4444;

	in.read((char*)dogs.data(), sizeof(Dog) * dogs.size());

	for (const auto& dog : dogs)
		std::cout << dog << std::endl;

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-03-24 오후 6:58:34 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 3월 24일 월요일				(3주 2일)
//-----------------------------------------------------------
// 많은 수의 자료를 다루기 - Dog를 읽고 쓸 수 있게
//-----------------------------------------------------------

#include <iostream>
#include <string>
#include <fstream>
#include <array>

#include "save.h"

// "Dog 10만 마리"에는 Dog객체 10만개가 저장되어 있다.
// 파일은 binary mode로 열었고 write를 사용하여 메모리 그대로 저장하였다.
// 메인 코드가 수정없이 실행될 수 있도록 필요한 코딩을 추가하라

class Dog{
private:
	std::string name{};
	int id{};

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.id << " - " << dog.name;
	}

	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		return is.read((char*)&dog, sizeof(Dog));
	}
};

std::array < Dog, 10'0000> dogs;

int main()
{
	std::ifstream in{ "Dog 10만 마리" ,std::ios::binary };
	if (not in) return 4444;

	for (int i = 0; i < dogs.size(); ++i) {
		in >> dogs[i];
	}

	for (const auto& dog : dogs) {
		std::cout << dog << std::endl;
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-03-27 오후 6:12:25 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 3월 27일 월요일				(4주 1일)
//-----------------------------------------------------------
// RAII와 smart pointer
//-----------------------------------------------------------

#include <iostream>
#include <numeric>
#include "save.h"

// [문제] 양의 정수(int의 최댓값까지)를 입력받아 num에 저장하라.
// int값을 num개 저장할 수 있는 메모리를 확보하라.
// 메모리의 내용을 1부터 시작하는 정수로 채워라.
// 메모리에 있는 값의 합계를 화면에 출력하라.
// 이 과정을 영원히 반복하라.

int main()
{
	save("메인.cpp");

	while (true) {
		std::cout << "양의 정수를 입력하시오. : ";
		int num{ 0 };

		std::cin >> num;


		//malloc(num * sizeof(int));	//HEAP - 반환값이 void*
		int *p = new int[num];			//free-store - 오퍼레이터이다. 즉 타입이 지정되어 사용한다.
		std::iota(p, p + num, 1);

		unsigned long long sum{};

		sum = std::accumulate(p, p + num, 0LL);

		std::cout << "1부터 " << num << "까지 합계 - " << sum << std::endl;
		delete[] p;
	}
}

==========================================
저장한 시간: 2025-03-27 오후 6:24:57 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 3월 27일 월요일				(4주 1일)
//-----------------------------------------------------------
// RAII와 smart pointer
//-----------------------------------------------------------

#include <iostream>
#include "save.h"

void f() {
	int* p = new int[20'0000'0000] { };

	std::cout << "메모리 확보" << std::endl;

	//delete[] p;
}

int main()
{
	try {
		while (true) {
			f();
		}
	}
	catch (const std::exception& e) {
		std::cout << e.what() << std::endl;
		save("메인.cpp");
	}

	
}

==========================================
저장한 시간: 2025-03-27 오후 6:50:42 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 3월 27일 월요일				(4주 1일)
//-----------------------------------------------------------
// RAII와 smart pointer
//-----------------------------------------------------------

#include <iostream>
#include "save.h"

class Dog {
public:
	Dog();
	~Dog();

private:

};

Dog::Dog() {
	std::cout << "Dog 생성됨" << std::endl;
}

Dog::~Dog() {
	std::cout << "Dog 소멸됨" << std::endl;
}

class 스마트 {
public:
	스마트(Dog* p) : p{ p } {};
	~스마트() {
		delete p;
	}
private:
	Dog* p;
};

void f() {
	스마트 p{ new Dog }; // RAII : 자원의 생명주기(life cycle)를 객체의 생명주기와 일치시키는 기법

	throw 2021182009;

	std::cout << "f가 끝나간다..." << std::endl;
}

int main()
{
	try {
		f();
	}
	catch ( ... ) {
		std::cout << "예외 잡음" << std::endl;
	}
	save("메인.cpp");
}

// C++은 지역 객체는 반드시 소멸함을 보증함. Stack을 돌아가며 소멸시킴(Stack unwinding)

==========================================
저장한 시간: 2025-03-27 오후 6:54:09 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 3월 27일 월요일				(4주 1일)
//-----------------------------------------------------------
// RAII와 smart pointer
//-----------------------------------------------------------

#include <iostream>
#include <memory>
#include "save.h"

class Dog {
public:
	Dog() {
		std::cout << "Dog 생성됨" << std::endl;
	}

	~Dog() {
		std::cout << "Dog 소멸됨" << std::endl;
	}
};



void f() {
	std::unique_ptr<Dog[]> p{new Dog[10]}; // 생성시에 자원을 바로 초기화함. = 을 사용하는 대입 연산 X

	std::cout << "f가 끝나간다." << std::endl;
}

int main()
{
	f();
	save("메인.cpp");
}

==========================================
저장한 시간: 2025-03-27 오후 6:59:28 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 3월 27일 월요일				(4주 1일)
//-----------------------------------------------------------
// RAII와 smart pointer
// 자원의 생명주기를 핸들러의 생명주기에 일치시키는 기법
//-----------------------------------------------------------

#include <iostream>
#include <memory>
#include "save.h"

class Dog {
public:
	Dog() {
		std::cout << "Dog 생성됨" << std::endl;
	}

	~Dog() {
		std::cout << "Dog 소멸됨" << std::endl;
	}
};



void f() {
	std::unique_ptr<Dog[]> p = std::make_unique<Dog[]>(10); // new 대신 도우미 함수
}

int main()
{
	f();
	save("메인.cpp");
}

==========================================
저장한 시간: 2025-03-31 오후 5:52:37 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 3월 31일 월요일				(4주 2일)
//-----------------------------------------------------------
// Callable types - 호출가능한 타입
// 1. 함수
//-----------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

// [문제] "메인.cpp"파일의 소문자를 대문자로 변환하여 "메인 대문자.cpp"에 저장하라

int main()
{
	std::ifstream in{ "메인.cpp" };
	if (not in) {
		return 2021182009;
	}

	std::ofstream out{ "메인 대문자.cpp" };

	std::transform(std::istreambuf_iterator<char>{in}, { }, std::ostreambuf_iterator<char>{std::cout},
		[](char c) {
			return toupper(c);
	});

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-03-31 오후 6:36:04 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 3월 31일 월요일				(4주 2일)
//-----------------------------------------------------------
// Callable types - 호출가능한 타입
// 1. 함수
//-----------------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <print>
#include <ranges>
#include "save.h"

// [문제] 값의 범위가 [0,1000'0000) 까지인 랜덤 int값 1000만개를 저장할 메모리를 확보하고 값을 채워라
// (시작) qsort로 오름차순 정렬하라
// 정렬한 결과 중에서 앞에서부터 1000개만 화면에 출력하라


std::random_device rd;
std::mt19937_64 dre(rd());
std::uniform_int_distribution<int> uid(0, 1000'0000 - 1);

std::array<int, 1000'0000> randomNumber;

int 오름차순(const void* a, const void * b) {
	return *(int*)a - *(int*)b;
}

int main()
{
	for (int& num : randomNumber) {
		num = uid(dre);
	}

	// qsort로 정렬
	//정렬방법 = 오름차순;
	//정렬방법 = 내림차순;
	std::qsort(randomNumber.data(), randomNumber.size(), sizeof(std::array<int, 1000'0000>::value_type), 오름차순);

	for ( int num : randomNumber | std::views::take(1000)) {
		std::print("{:8}", num);
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-03-31 오후 6:51:51 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 3월 31일 월요일				(4주 2일)
//-----------------------------------------------------------
// Callable types - 호출가능한 타입
// 1. 함수
//-----------------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <print>
#include <ranges>
#include "save.h"

// [문제] 값의 범위가 [0,1000'0000) 까지인 랜덤 int값 1000만개를 저장할 메모리를 확보하고 값을 채워라
// (시작) qsort로 오름차순 정렬하라
// 정렬한 결과 중에서 앞에서부터 1000개만 화면에 출력하라

std::mt19937_64 dre(std::random_device{}());
std::uniform_int_distribution<int> uid(0, 1000'0000 - 1);

std::array<int, 1000'0000> randomNumber;

int 오름차순(const void* a, const void * b) {
	return *(int*)a - *(int*)b;
}

int 내림차순(const void* a, const void* b) {
	return *(int*)b - *(int*)a;
}

int main()
{
	for (int& num : randomNumber) {
		num = uid(dre);
	}

	// qsort로 정렬
	
	int (*정렬방법)(const void*, const void*);

	정렬방법 = 오름차순;
	//정렬방법 = 내림차순;

	std::qsort(randomNumber.data(), randomNumber.size(), sizeof(int), 정렬방법);

	for ( int num : randomNumber | std::views::take(1000)) {
		std::print("{:8}", num);
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-03-31 오후 7:01:10 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 3월 31일 월요일				(4주 2일)
//-----------------------------------------------------------
// Callable types - 호출가능한 타입
// 1. 함수
//-----------------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <print>
#include <ranges>
#include <algorithm>
#include "save.h"

std::mt19937_64 dre(std::random_device{}());
std::uniform_int_distribution<int> uid(0, 1000'0000 - 1);

std::array<int, 1000'0000> randomNumber;

int main()
{
	for (int& num : randomNumber) {
		num = uid(dre);
	}

	// STL의 sort로 정렬
	std::sort(randomNumber.begin(), randomNumber.end());

	for ( int num : randomNumber | std::views::take(1000)) {
		std::print("{:8}", num);
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-03-31 오후 7:05:20 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 3월 31일 월요일				(4주 2일)
//-----------------------------------------------------------
// Callable types - 호출가능한 타입
// 1. 함수
//-----------------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"

std::mt19937_64 dre(std::random_device{}());
std::uniform_int_distribution<int> uid(0, 1000'0000 - 1);

std::array<int, 1000'0000> randomNumber;

int main()
{
	for (int& num : randomNumber) {
		num = uid(dre);
	}

	// STL의 sort로 내림차순 정렬
	// 정렬에 걸리는 시간
	// 스톱워치 시작
	auto b = std::chrono::high_resolution_clock::now();
	std::sort(randomNumber.begin(), randomNumber.end(), [] (int a, int b) {
		return a > b;
		});
	auto e = std::chrono::high_resolution_clock::now();
	// 스톱워치 끝

	for ( int num : randomNumber | std::views::take(1000)) {
		std::print("{:8}", num);
	}

	std::cout << std::endl << "정렬에 걸린 시간 : " << e - b << std::endl;

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-04-03 오후 5:45:50 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 4월 03일 목요일				(5주 1일)
// 중간고사(30)	- 4월 24일 목요일 (8주 1일)
// 과제설명(30)	- 4월 10일 목요일 (6주 1일)
//-----------------------------------------------------------
// Callable types - 호출가능한 타입
// 1. 함수
//-----------------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"

std::mt19937_64 dre(std::random_device{}());
std::uniform_int_distribution<int> uid(0, 1000'0000 - 1);

std::array<int, 1000'0000> randomNumber;

bool 내림차순(int a, int b) {
	return a > b;
}

int main()
{
	{
		// sort로 내림차순 정렬
		for (int& num : randomNumber) {
			num = uid(dre);
		}
		auto b = std::chrono::high_resolution_clock::now();
		std::sort(randomNumber.begin(), randomNumber.end(), 내림차순);
		auto e = std::chrono::high_resolution_clock::now();

		std::cout << "정렬 경과(duration)시간 (함수) : " << e - b << std::endl;

	}

	{
		// STL의 sort로 내림차순 정렬 -> 람다로 코딩
		for (int& num : randomNumber) {
			num = uid(dre);
		}
		auto b = std::chrono::high_resolution_clock::now();
		std::sort(randomNumber.begin(), randomNumber.end(), [](int a, int b)
			{return a > b; });
		auto e = std::chrono::high_resolution_clock::now();

		std::cout << "정렬 경과(duration)시간 (람다) : " << e - b << std::endl;

	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-04-03 오후 6:09:29 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 4월 03일 목요일				(5주 1일)
// 중간고사(30)	- 4월 24일 목요일 (8주 1일)
// 과제설명(30)	- 4월 10일 목요일 (6주 1일)
//-----------------------------------------------------------
// Callable types - 호출가능한 타입
// 1. 함수
// 2. 함수 포인터
// 3. 람다
// 4. 함수객체
// 5. 멤버함수
//-----------------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <print>
#include <ranges>
#include <algorithm>
#include <chrono>
#include "save.h"

std::mt19937_64 dre(std::random_device{}());
std::uniform_int_distribution<int> uid(0, 1000'0000 - 1);

std::array<int, 1000'0000> randomNumber;

bool 내림차순(int a, int b) {
	return a > b;
}

int main()
{
	{
		// sort로 내림차순 정렬
		for (int& num : randomNumber) {
			num = uid(dre);
		}
		auto b = std::chrono::high_resolution_clock::now();
		std::sort(randomNumber.begin(), randomNumber.end(), 내림차순);
		auto e = std::chrono::high_resolution_clock::now();

		std::cout << "정렬 경과(duration)시간 (함수) : " << e - b << std::endl;
	}
	
	{
		// STL의 sort로 내림차순 정렬 -> 람다로 코딩
		for (int& num : randomNumber) {
			num = uid(dre);
		}
		auto b = std::chrono::high_resolution_clock::now();
		std::sort(randomNumber.begin(), randomNumber.end(), [](int a, int b)
			{return a > b; });
		auto e = std::chrono::high_resolution_clock::now();

		std::cout << "정렬 경과(duration)시간 (람다) : " << e - b << std::endl;
	}

	// sort는 템플릿 함수. 원형은 sort<T>(); 즉, 컴파일 시 소스 코드를 생성 ->	함수를 적어 놓으면 함수 호출문을 생성
	//									람다면 코드 자체를 적음(인라인화) => 함수 호출X = function call에 소요되는 overhead가 없음

	for (int num : randomNumber | std::ranges::views::reverse | std::ranges::views::take(1000)) {
		std::print("{:8}", num);
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-04-03 오후 6:25:17 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 4월 03일 목요일				(5주 1일)
// 중간고사(30)	- 4월 24일 목요일 (8주 1일)
// 과제설명(30)	- 4월 10일 목요일 (6주 1일)
//-----------------------------------------------------------
// Callable types - 호출가능한 타입
// 1. 함수
// 2. 함수 포인터
// 3. 람다
// 4. 함수객체
// 5. 멤버함수
//-----------------------------------------------------------

#include <iostream>
#include "save.h"

class ABC {
	// [] () {};
	// 람다 인트로듀서[] -> operator()
public:
	void operator()() {
		std::cout << "나는 람다람쥐야!" << std::endl;
	};
};

int main()
{

	ABC f;

	f();

	std::cout << "람다의 정체 - " << typeid(f).name() << std::endl;
	// 충격진실 람다는 클래스이다. (비쥬얼 스튜디오에서는)
	save("메인.cpp");
}

==========================================
저장한 시간: 2025-04-03 오후 6:29:20 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 4월 03일 목요일				(5주 1일)
// 중간고사(30)	- 4월 24일 목요일 (8주 1일)
// 과제설명(30)	- 4월 10일 목요일 (6주 1일)
//-----------------------------------------------------------
// Callable types - 호출가능한 타입
// 1. 함수
// 2. 함수 포인터
// 3. 람다
// 4. 함수객체
// 5. 멤버함수
//-----------------------------------------------------------

#include <iostream>
#include "save.h"

class Dog {
public:
	void operator()(const int n) {
		std::cout << "개" << std::endl;
	}
};

int main()
{
	Dog dog;

	dog(1); //함수 호출 연산자(function-call operator)도 오버로딩 가능하다. 

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-04-03 오후 6:34:26 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 4월 03일 목요일				(5주 1일)
// 중간고사(30)	- 4월 24일 목요일 (8주 1일)
// 과제설명(30)	- 4월 10일 목요일 (6주 1일)
//-----------------------------------------------------------
// Callable types - 호출가능한 타입
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수인데, VS에서는 함수객체를 이용하여 람다를 구현함
// 4. 함수객체(function object) - 함수호출연산자를 오버로딩한 클래스의 객체
// 5. 멤버함수
//-----------------------------------------------------------

#include <iostream>
#include "save.h"

class Dog {
public:
	void operator()(const int n) {
		std::cout << "개" << std::endl;
	}
};

int main()
{
	int a, b;
	a = b;	//a와 b의 타입이 같다면 이 문장은 언제나 참이다.

	Dog dog;

	dog(1); //함수 호출 연산자(function-call operator)도 오버로딩 가능하다. 

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-04-03 오후 6:39:31 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 4월 03일 목요일				(5주 1일)
// 중간고사(30)	- 4월 24일 목요일 (8주 1일)
// 과제설명(30)	- 4월 10일 목요일 (6주 1일)
//-----------------------------------------------------------
// Callable types - 호출가능한 타입
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수인데, VS에서는 함수객체를 이용하여 람다를 구현함
// 4. 함수객체(function object) - 함수호출연산자를 오버로딩한 클래스의 객체
// 5. 멤버함수
//-----------------------------------------------------------

#include <iostream>
#include "save.h"

class Dog {
public:
	void operator()(const int n) {
		std::cout << "개" << std::endl;
	}
};

int main()
{
	//void a(int);
	//void b(int);

	//void(*f)(int) = a;
	//f = b;

	// lvalue는 location value 메모리 주소를 가지는 값으로, 변수나 객체처럼 수정 가능한 표현식

	Dog dog;

	dog(1); //함수 호출 연산자(function-call operator)도 오버로딩 가능하다. 

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-04-03 오후 6:44:00 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 4월 03일 목요일				(5주 1일)
// 중간고사(30)	- 4월 24일 목요일 (8주 1일)
// 과제설명(30)	- 4월 10일 목요일 (6주 1일)
//-----------------------------------------------------------
// Callable types - 호출가능한 타입
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수인데, VS에서는 함수객체를 이용하여 람다를 구현함
// 4. 함수객체(function object) - 함수호출연산자를 오버로딩한 클래스의 객체
// 5. 멤버함수
// 1,2는 함수 3,4는 클래스
//-----------------------------------------------------------

#include <iostream>
#include "save.h"

class Dog {
public:
	void operator()(const int n) {
		std::cout << "개" << std::endl;
	}
};

int main()
{
	//void a(int);
	//void b(int);

	//void(*f)(int) = a;
	//f = b;

	// lvalue는 location value 메모리 주소를 가지는 값으로, 변수나 객체처럼 수정 가능한 표현식

	Dog dog;

	dog(1); //함수 호출 연산자(function-call operator)도 오버로딩 가능하다. 

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-04-03 오후 6:48:05 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 4월 03일 목요일				(5주 1일)
// 중간고사(30)	- 4월 24일 목요일 (8주 1일)
// 과제설명(30)	- 4월 10일 목요일 (6주 1일)
//-----------------------------------------------------------
// Callable types - 호출가능한 타입 ==> 모든 호출가능타입을 대표하는 function
// 1. 함수
// 2. 함수 포인터
// 3. 람다 - 이름없는 함수인데, VS에서는 함수객체를 이용하여 람다를 구현함
// 4. 함수객체(function object) - 함수호출연산자를 오버로딩한 클래스의 객체
// 5. 멤버함수
// 1,2는 함수 3,4는 클래스
//-----------------------------------------------------------

#include <iostream>
#include <functional>
#include "save.h"

class Dog {
public:
	void operator()(const int n) {
		std::cout << "개" << std::endl;
	}
};

int main()
{
	save("메인.cpp");
	//int a(int);
	//void b(int);

	//std::function<int(int)> f = a; // 대표 표기법

}

==========================================
저장한 시간: 2025-04-03 오후 6:52:37 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 4월 03일 목요일				(5주 1일)
// 중간고사(30)	- 4월 24일 목요일 (8주 1일)
// 과제설명(30)	- 4월 10일 목요일 (6주 1일)
//-----------------------------------------------------------
// Callable types - 호출가능한 타입 ==> 모든 호출가능타입을 대표하는 function
//-----------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"

using namespace std;


int main()
{
	array<int, 10> a{ 1,3,5,7,9,2,4,6,8,10 };

	//[문제] 오름차순으로 정렬하고 출력하라.

	class Dog {
	public:
		bool operator()(int a, int b) const {
			return a < b;
		}
	};

	Dog dog;
	sort(a.begin(), a.end(), dog);

	for (int num : a) {
		cout << num << ' ';
	}
	cout << endl;

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-04-03 오후 7:02:49 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 4월 03일 목요일				(5주 1일)
// 중간고사(30)	- 4월 24일 목요일 (8주 1일)
// 과제설명(30)	- 4월 10일 목요일 (6주 1일)
//-----------------------------------------------------------
// Callable types - 호출가능한 타입 ==> 모든 호출가능타입을 대표하는 function
//-----------------------------------------------------------

#include <iostream>
#include <random>
#include <fstream>
#include "save.h"

using namespace std;

// [상황] Dog객체 10만개를 파일 "Dog 10만마리"에 저장한다.
// 파일은 ofstream out( "Dog 10만마리" );
// Dog 타입의 객체 dog를 out << dog; 로 저장하였다.

default_random_engine dre;
uniform_int_distribution uid;
uniform_int_distribution uidLen{ 3,59 };
uniform_int_distribution<int> uidName{ 'a','z' };

class Dog {
public:
	Dog() {
		num = uid(dre);
		int len = uidLen(dre);
		for (int i = 0; i < len; ++i) {
			name += uidName(dre);
		}
	}
private:
	size_t num;		// 랜덤 int 값
	string name;	// [3,60) 까지의 랜덤 소문자로만 구성

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.num << " " << dog.name << " ";
	}
};

int main(){

	ofstream out{ "Dog 십만마리" };

	for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		out << dog << endl;
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-04-03 오후 7:07:07 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 4월 03일 목요일				(5주 1일)
// 중간고사(30)	- 4월 24일 목요일 (8주 1일)
// 과제설명(30)	- 4월 10일 목요일 (6주 1일)
//-----------------------------------------------------------
// Callable types - 호출가능한 타입 ==> 모든 호출가능타입을 대표하는 function
//-----------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

using namespace std;

// [상황] e-class에서 다운받은 "Dog 십만마리"에는
// 정확하게 Dog객체 10만개가 저장되어 있다.
// 파일은
//			ofstream out( "Dog 십만마리" );
// Dog 타입의 객체 dog를
//			out << dog;
// 로 저장하였다.

class Dog {
private:
	size_t num;		// 랜덤 int 값
	string name;	// [3,60) 까지의 랜덤 소문자로만 구성

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.num << " " << dog.name << " ";
	}
};

// [문제] 파일에 저장된 10만개의 Dog객체를 모두 읽어 메모리에 저장하라.
// 마지막 객체의 정보를 화면에 출력하고 출력된 내용을 답지에도 적어라.
// 메모리에 있는 Dog 객체를 name 길이기준 오름차순으로 정렬하라.
// 정렬한 마지막 객체의 정보를 화면에 출력하고 답지에도 적어라.

int main(){

	
	save("메인.cpp");
}

==========================================
저장한 시간: 2025-04-07 오후 6:11:15 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 4월 07일 월요일				(5주 2일)
// 중간고사(30)	- 4월 24일 목요일 (8주 1일)
// 과제설명(30)	- 4월 10일 목요일 (6주 1일)
//-----------------------------------------------------------
// Callable types - 호출가능한 타입 ==> 모든 호출가능타입을 대표하는 function
//-----------------------------------------------------------

#include <iostream>
#include <string>
#include <fstream>
#include <array>
#include <algorithm>
#include <print>
#include "save.h"

using namespace std;

// [상황] e-class에서 다운받은 "Dog 십만마리"에는
// 정확하게 Dog객체 10만개가 저장되어 있다.
// 파일은
//			ofstream out( "Dog 십만마리" );
// Dog 타입의 객체 dog를
//			out << dog;
// 로 저장하였다.

class Dog {
private:
	size_t num;		// 랜덤 int 값
	string name;	// [3,60) 까지의 랜덤 소문자로만 구성

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.num << " " << dog.name << " ";
	}

	friend istream& operator>>(istream& is, Dog& dog) {
		return is >> dog.num >> dog.name;
	}

public:
	bool operator<(const Dog& rhs) const {
		return this->name.length() < rhs.name.length();
	}

	void show() const {
		print("{:12} - {}\n", num, name);
	}
};

// [문제] 파일에 저장된 10만개의 Dog객체를 모두 읽어 메모리에 저장하라.
// 마지막 객체의 정보를 화면에 출력하고 출력된 내용을 답지에도 적어라.
// 메모리에 있는 Dog 객체를 name 길이기준 오름차순으로 정렬하라.
// 정렬한 마지막 객체의 정보를 화면에 출력하고 답지에도 적어라.

array<Dog, 10'0000> dogs;

int main(){
	ifstream in{ "Dog 십만마리" };
	if (not in) return 2021182009;

	for (Dog& dog : dogs) {
		in >> dog;
	}

	cout << "마지막 객체 : ";
	dogs.back().show();

	cout << endl << "===정렬===" << endl;


	// sort는 기본 연산자로 < 를 사용한다. [상위 버전에서는 less<>{} 를 사용한다?]
	// 따라서 Dog < Dog가 가능하다면 아무 문제가 없다.
	sort(dogs.begin(), dogs.end());

	for (const Dog& dog : dogs) {
		dog.show();
	}

	cout << "마지막 객체 : ";
	dogs.back().show();

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-04-07 오후 6:38:13 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 4월 07일 월요일				(5주 2일)
// 중간고사(30)	- 4월 24일 목요일 (8주 1일)
// 과제설명(30)	- 4월 10일 목요일 (6주 1일)
//-----------------------------------------------------------
// class STRING 작성시작 - std::string과 유사한 동작을 한다.
//-----------------------------------------------------------

// 절차적 프로그래밍
// OOPL(객체지향언어) - 특정 자료형만을 위한 코딩, 객체들과의 상호 동작으로 문제 해결, 역할 / 책임 / 관계를 가지는 객체 => virtual -> 다형성
// Generic PL - 자료형과 관계없는 코딩 (함수 -> 알고리즘, 클래스 -> 자료구조) => template
// Meta programming
// Functional programming

#include <iostream>
#include "save.h"

using namespace std;

int main(){

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-04-07 오후 7:04:45 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 4월 07일 월요일				(5주 2일)
// 중간고사(30)	- 4월 24일 목요일 (8주 1일)
// 과제설명(30)	- 4월 10일 목요일 (6주 1일)
//-----------------------------------------------------------
// class STRING 작성시작 - std::string과 유사한 동작을 한다.
//-----------------------------------------------------------

#include <iostream>
#include <string>
#include <memory>
#include "save.h"

using namespace std;

class STRING {
public:
	STRING(const char* str) : num{ strlen(str) } { // T[N] -> T* collapsing
		p.release();					// 생성시에 이렇게 할 필요는 없다.
		p = make_unique<char[]>(num);
		memcpy(p.get(), str, num);		// DMA(Direct Memory Access)가 가능하다. CPU거치지 않고 초고속 메모리 복사.
	};

	size_t size() const {
		return num;
	};

private:
	size_t num{};
	unique_ptr<char[]> p{};

	friend ostream& operator<<(ostream& os, const STRING& s) {
		for (int i = 0; i < s.num; ++i) {
			os << s.p[i];
		}
		return os;
	}
};


int main(){
	STRING s{ "std::string과 유사한 클래스" };

	cout << "s가 관리하는 자원의 바이트 수 : " << s.size() << endl;

	//STRING t = s;
	cout << s << endl;
	//cout << t << endl;
	save("메인.cpp");
}

==========================================
저장한 시간: 2025-04-10 오후 6:05:00 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 4월 10일 목요일				(6주 1일)
// 중간고사(30)	- 4월 24일 목요일 (8주 1일)
//-----------------------------------------------------------
// class STRING 작성시작 - STL의 표준 컨테이너가 되도록 발전시킨다.
//-----------------------------------------------------------

#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"

using namespace std;

int main(){
	STRING s{ "std::string과 유사한 클래스" };

	cout << "s가 관리하는 자원의 바이트 수 : " << s.size() << endl;

	//STRING t = s;
	cout << s << endl;
	//cout << t << endl;
	
	save("메인.cpp");
}

==========================================
저장한 시간: 2025-04-10 오후 6:42:19 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 4월 10일 목요일				(6주 1일)
// 중간고사(30)	- 4월 24일 목요일 (8주 1일)
//-----------------------------------------------------------
// class STRING 작성시작 - STL의 표준 컨테이너가 되도록 발전시킨다.
//-----------------------------------------------------------

#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"

using namespace std;

int main(){
	STRING s{ "std::string과 유사한 클래스" };

	STRING t;

	STRING u = s;

	cout << s << endl;
	cout << u << endl;
	
	save("메인.cpp");
}

==========================================
저장한 시간: 2025-04-10 오후 7:02:35 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 4월 10일 목요일				(6주 1일)
// 중간고사(30)	- 4월 24일 목요일 (8주 1일)
//-----------------------------------------------------------
// class STRING 작성시작 - STL의 표준 컨테이너가 되도록 발전시킨다.
//-----------------------------------------------------------

#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"

using namespace std;

int main(){
	STRING s;
	
	save("메인.cpp");
}

==========================================
저장한 시간: 2025-04-10 오후 7:04:13 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 4월 10일 목요일				(6주 1일)
// 중간고사(30)	- 4월 24일 목요일 (8주 1일)
//-----------------------------------------------------------
// class STRING 작성시작 - STL의 표준 컨테이너가 되도록 발전시킨다.
//-----------------------------------------------------------

#include <iostream>
#include <string>
#include <memory>
#include "save.h"
#include "STRING.h"

using namespace std;

int main(){
	STRING s;
	
	save("메인.cpp");
}

==========================================
저장한 시간: 2025-04-14 오후 5:41:37 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 4월 14일 월요일				(6주 2일)
// 중간고사(30)	- 4월 24일 목요일 (8주 1일)
//-----------------------------------------------------------
// class STRING 작성시작 - STL의 표준 컨테이너가 되도록 발전시킨다.
//-----------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){
	관찰 = true;
	array<STRING, 5> a{ "1","333","55555","22","4444" };

	//[문제] a의 원소를 길이기준 오름차순으로 정렬하고 화면에 출력하라
	sort(a.begin(), a.end(), [](const STRING& a, const STRING& b)
		{
			return a.size() < b.size();
		});

	for (const STRING& data : a)
	{
		cout << data << " ";
	}
	cout << endl;

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-04-14 오후 6:27:38 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 4월 14일 월요일				(6주 2일)
// 중간고사(30)	- 4월 24일 목요일 (8주 1일)
//-----------------------------------------------------------
// class STRING 작성시작 - STL의 표준 컨테이너가 되도록 발전시킨다.
//-----------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){
	array<STRING, 5> a{ "1","333","55555","22","4444" };

	for (const STRING& data : a)
	{
		cout << data << endl;
	}

	관찰 = true;
	//[문제] a의 원소를 길이기준 오름차순으로 정렬하고 화면에 출력하라
	sort(a.begin(), a.end(), [](const STRING& lhs, const STRING& rhs)
		{
			return lhs.size() < rhs.size();
		});
	관찰 = false;

	for (const STRING& data : a)
	{
		cout << data << endl;
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-04-14 오후 6:53:57 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 4월 14일 월요일				(6주 2일)
// 중간고사(30)	- 4월 24일 목요일 (8주 1일)
//-----------------------------------------------------------
// class STRING 작성시작 - STL의 표준 컨테이너가 되도록 발전시킨다.
//-----------------------------------------------------------

#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){
	// [문제] 메인.cpp에 있는 단어를 처음부터 50개를 메모리(STRING)에 저장하자
	// 전체 단어를 길이 오름차순으로 정렬하자. 결과를 화면에 출력하라
	// 제일 첫 단어를 답지에 적어라
	ifstream in{ "메인.cpp" };
	if (not in) return 2021182009;
	
	array<STRING, 50> words;
	for (STRING& word : words)
	{
		in >> word;
	}

	sort(words.begin(), words.end(), [](const STRING& lhs, const STRING& rhs)
		{
			return lhs.size() < rhs.size();
		});

	for (const STRING& word : words)
	{
		cout << word << endl;
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-04-14 오후 7:02:31 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 4월 14일 월요일				(6주 2일)
// 중간고사(30)	- 4월 24일 목요일 (8주 1일)
//-----------------------------------------------------------
// class STRING 작성시작 - STL의 표준 컨테이너가 되도록 발전시킨다.
//-----------------------------------------------------------

#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){
	// [문제] 메인.cpp에 있는 단어를 처음부터 50개를 메모리(STRING)에 저장하자
	// 전체 단어를 길이 오름차순으로 정렬하자. 결과를 화면에 출력하라
	// 제일 첫 단어를 답지에 적어라
	ifstream in{ "메인.cpp" };
	if (not in) return 2021182009;
	
	array<STRING, 50> words;
	for (STRING& word : words)
	{
		in >> word;
	}

	sort(words.begin(), words.end());

	// 다음 시간에 STL이란 무엇인가?
	for ( auto i = words.rbegin(); i != words.rend(); ++i)
	{
		cout << *i << endl;
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-04-17 오후 7:02:18 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 4월 17일 목요일				(7주 1일)
// 중간고사(30)	- 4월 24일 목요일 (8주 1일)
//-----------------------------------------------------------
// STL Container - Containers are objects that store other objects.
//-----------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){
	vector<int> v;

	cout << "v의 원소 개수 - " << v.size() << endl;
	cout << "v의 용량 - " << v.capacity() << endl;
	cout << "v의 원소 주소 - " << v.data()<< endl;

	v.push_back(1);
	cout << "원소 1개 추가한 후 vector v의 field" << endl;

	cout << "v의 원소 개수 - " << v.size() << endl;
	cout << "v의 용량 - " << v.capacity() << endl;
	cout << "v의 원소 주소 - " << v.data() << endl;
	save("메인.cpp");
}

==========================================
저장한 시간: 2025-04-21 오후 6:21:59 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 4월 21일 월요일				(7주 2일)
// 중간고사(30)	- 4월 24일 목요일 (8주 1일)
//-----------------------------------------------------------
// STL Container - Containers are objects that store other objects.
// array - 
// vector - 
//-----------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] vector는 어떻게 메모리를 관리하는가??
// size > capacity => 재할당

int main(){
	vector<int> v;
	v.reserve(10000);

	int i{ 0 };

	size_t old = v.capacity();

	for (int i = 0; i < 10000; ++i)
	{
		v.push_back(i);
		if (old != v.capacity())
		{
			cout << "v가 재할당하지 않고 원소를 담을 수 있는 개수" << v.capacity() << endl;
			old = v.capacity();
			
		}
	}


	save("메인.cpp");
}

==========================================
저장한 시간: 2025-04-21 오후 6:30:41 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 4월 21일 월요일				(7주 2일)
// 중간고사(30)	- 4월 24일 목요일 (8주 1일)
//-----------------------------------------------------------
// STL Container - Containers are objects that store other objects.
// array - 
// vector - 
//-----------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] 키보드에서 단어를 모두 입력받아 오름차순으로 정렬한 후 출력하라.

int main(){
	vector<string> v{ istream_iterator<string>{cin},{} };

	sort(v.begin(), v.end());

	for (const auto& data : v)
	{
		cout << data << endl;
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-04-21 오후 6:31:32 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 4월 21일 월요일				(7주 2일)
// 중간고사(30)	- 4월 24일 목요일 (8주 1일)
//-----------------------------------------------------------
// STL Container - Containers are objects that store other objects.
// array - 
// vector - 
//-----------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <string>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] 키보드에서 단어를 모두 입력받아 오름차순으로 정렬한 후 출력하라.

int main(){
	ifstream in{ "메인.cpp" };

	vector<string> v{ istream_iterator<string>{in},{} };

	sort(v.begin(), v.end());

	for (const auto& data : v)
	{
		cout << data << endl;
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-04-21 오후 6:45:32 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 4월 21일 월요일				(7주 2일)
// 중간고사(30)	- 4월 24일 목요일 (8주 1일)
//-----------------------------------------------------------
// STL Container - Containers are objects that store other objects.
// array - 
// vector - 
//-----------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){
	관찰 = true;

	vector<STRING> v;

	STRING s{ "12345" };
	
	v.push_back( s ); // => const STRING& s (복사생성)

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-04-21 오후 6:59:14 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 4월 21일 월요일				(7주 2일)
// 중간고사(30)	- 4월 24일 목요일 (8주 1일)
//-----------------------------------------------------------
// STL Container - Containers are objects that store other objects.
// array - 
// vector - 
//-----------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){
	관찰 = true;

	vector<STRING> v;
	
	v.push_back( STRING { "12345" } ); // => STRING&& (이동생성)

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-04-21 오후 7:03:02 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 4월 21일 월요일				(7주 2일)
// 중간고사(30)	- 4월 24일 목요일 (8주 1일)
//-----------------------------------------------------------
// STL Container - Containers are objects that store other objects.
// array - 
// vector - 
//-----------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){
	관찰 = true;

	vector<STRING> v;
	
	v.emplace_back("12345"); // 인자만 전달 => 관리하는 메모리에서 생성자를 호출

	cout << "==========" << endl;

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-04-28 오후 6:50:14 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 4월 28일 월요일				(8주 2일)
//-----------------------------------------------------------
// STL Container - Containers are objects that store other objects.
// array - 
// vector - 
//-----------------------------------------------------------

#include <iostream>
#include <vector>
#include <array>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){	
	save("메인.cpp");

	vector<int> vec{ 1,2,3,4,5,6,7,8,9,10 };
	array<int,10> arr{ 1,2,3,4,5,6,7,8,9,10 };

	while (true)
	{
		cout << "몇번째 데이터를 원하는가:";
		int num;
		cin >> num;

		try
		{
			cout << "찾은 값 :" << vec.at(num) << endl;
		}
		catch (const std::exception& e)
		{
			cout << e.what();
			cout << " - 0부터 9까지 값을 입력해주세요." << endl;
		}
	}

}

==========================================
저장한 시간: 2025-05-01 오후 5:56:57 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 01일 목요일				(9주 1일)
// 2025.05.05 -> 추후 보강 (6/19) <- 종강
//-----------------------------------------------------------
// STL Container - Containers are objects that store other objects.
// array - 
// vector - 
// STL의 알고리즘 1.수정X 2.수정O 3.정렬
//-----------------------------------------------------------

#include <iostream>
#include <vector>
#include <array>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){	
	vector<int> v{ 1,2,3,4,5 };

	// [문제] v에서 3을 제거하라

	//vector<int>::iterator NewEnd = remove(v.begin(), v.end(), 3); 원형
	auto NewEnd = remove(v.begin(), v.end(), 3);

	v.erase(NewEnd, v.end());

	for (int i = 0; i < v.size(); ++i)
	{
		cout << v[i] << " ";
	}
	cout << endl;

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-01 오후 5:58:44 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 01일 목요일				(9주 1일)
// 2025.05.05 -> 추후 보강 (6/19) <- 종강
//-----------------------------------------------------------
// STL Container - Containers are objects that store other objects.
// array - 
// vector - 
// STL의 알고리즘 1.수정X 2.수정O 3.정렬
//-----------------------------------------------------------

#include <iostream>
#include <vector>
#include <array>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){	
	vector<int> v{ 1,2,3,4,5 };

	// [문제] v에서 3을 제거하라

	//vector<int>::iterator NewEnd = remove(v.begin(), v.end(), 3); 원형
	auto NewEnd = remove(v.begin(), v.end(), 3);

	v.erase(NewEnd, v.end());

	for (int i = 0; i < v.size(); ++i)
	{
		cout << v[i] << " ";
	}
	cout << endl;

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-01 오후 6:04:12 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 01일 목요일				(9주 1일)
// 2025.05.05 -> 추후 보강 (6/19) <- 종강
//-----------------------------------------------------------
// STL Container - Containers are objects that store other objects.
// array - 
// vector - 
// STL의 알고리즘 1.수정X 2.수정O 3.정렬
//-----------------------------------------------------------

#include <iostream>
#include <vector>
#include <array>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){	
	vector<int> v{ 1,2,3,4,5 };

	// [문제] v에서 3을 제거하라

	//vector<int>::iterator NewEnd = remove(v.begin(), v.end(), 3); 원형

	// erase-remove idiom
	//v.erase(remove(v.begin(), v.end(), 3), v.end());
	// C++20
	erase(v, 3); // syntactic sugar erase-remove idiom이 그대로 실행됨

	for (int i = 0; i < v.size(); ++i)
	{
		cout << v[i] << " ";
	}
	cout << endl;

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-01 오후 6:33:03 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 01일 목요일				(9주 1일)
// 2025.05.05 -> 추후 보강 (6/19) <- 종강
//-----------------------------------------------------------
// STL Container - Containers are objects that store other objects.
// array - 
// vector - 
// STL의 알고리즘 1.수정X 2.수정O 3.정렬
//-----------------------------------------------------------

#include <iostream>
#include <vector>
#include <array>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){	
	vector<STRING> v{ "1","22","333","4444","55555" };

	// [문제] v에서 3을 제거하라
	관찰 = true;
	erase(v, "333");
	관찰 = false;

	for (const STRING& s : v)
	{
		cout << s << endl;
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-01 오후 6:50:32 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 01일 목요일				(9주 1일)
// 2025.05.05 -> 추후 보강 (6/19) <- 종강
//-----------------------------------------------------------
// STL Container - Containers are objects that store other objects.
// array - 
// vector - 
// STL의 알고리즘 1.수정X 2.수정O 3.정렬
//-----------------------------------------------------------

#include <iostream>
#include <vector>
#include <array>
#include <list>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){	
	list<STRING> v{ "1","22","333","4444","55555" };

	// [문제] v에서 3을 제거하라
	관찰 = true;
	v.remove("333");
	//erase(v, "333");	이 코드가 물론 실행되지만 비효율적 / list는 더 효율적으로 삭제 가능
	관찰 = false;

	for (const STRING& s : v)
	{
		cout << s << endl;
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-01 오후 6:53:04 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 01일 목요일				(9주 1일)
// 2025.05.05 -> 추후 보강 (6/19) <- 종강
//-----------------------------------------------------------
// STL Container - Containers are objects that store other objects.
// array - 
// vector - 
// STL의 알고리즘 1.수정X 2.수정O 3.정렬
//-----------------------------------------------------------

#include <iostream>
#include <vector>
#include <array>
#include <list>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){	
	list<STRING> v{ "1","22","333","4444","55555" };

	STRING t{ "333" };
	// [문제] v에서 3을 제거하라
	관찰 = true;
	v.remove(t);
	//erase(v, "333");	이 코드가 물론 실행되지만 비효율적 / list는 더 효율적으로 삭제 가능
	관찰 = false;

	for (const STRING& s : v)
	{
		cout << s << endl;
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-01 오후 7:01:42 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 08일 목요일				(9주 2일)
// 2025.05.05 -> 추후 보강 (6/19) <- 종강
//-----------------------------------------------------------
// STL Container - Containers are objects that store other objects.
// array<T,N> - 유일하게 크기가 고정
// vector<T> - random access가 가능(=> [] 연산자 제공), O(1)(상수시간) access, O(1) push_back()
// deque<T> - random access, []연산자, O(1) access, O(1) push_front(), push_back()
// STL의 알고리즘 1.수정X 2.수정O 3.정렬
//-----------------------------------------------------------

#include <iostream>
#include <deque>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){	
	deque<int> deq;
	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-08 오후 5:57:58 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 08일 목요일				(9주 2일)
// 6/19 목요일 15주 2일 - 기말시험
// 5/12 월요일 - 졸업작품 중간발표수업은 한다.
//-----------------------------------------------------------
// STL Container - Containers are objects that store other objects.
// array<T,N> - 유일하게 크기가 고정
// vector<T> - random access가 가능(== [] 연산자 제공), O(1)(상수시간) access, O(1) push_back()
// deque<T> - random access, []연산자, O(1) access, O(1) push_front(), push_back()
// list<T> - O(1) insert, delete, 자료구조를 활용한 전용함수 제공(remove, sort, splice)
// STL의 알고리즘 1.수정X 2.수정O 3.정렬
//-----------------------------------------------------------

#include <iostream>
#include <vector>
#include <deque>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

class Test
{
	char x[1'000'000];
};

int main(){	

	{ // 27310
		vector<Test> vec;
		while (true) {
			try
			{
				vec.emplace_back();
			}
			catch (const std::exception& e)
			{
				cout << e.what() << endl;
				cout << "최대 개수 - " << vec.size() << endl;
				break;
			}
		}
	}

	{ // 58802
		deque<Test> vec;
		while (true)
		{
			try
			{
				vec.emplace_back();
			}
			catch (const std::exception& e)
			{
				cout << e.what() << endl;
				cout << "최대 개수 - " << vec.size() << endl;
				break;
			}
		}
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-08 오후 6:10:55 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 08일 목요일				(9주 2일)
// 6/19 목요일 15주 2일 - 기말시험
// 5/12 월요일 - 졸업작품 중간발표수업은 한다.
//-----------------------------------------------------------
// STL Container - Containers are objects that store other objects.
// array<T,N> - 유일하게 크기가 고정
// vector<T> - random access가 가능(== [] 연산자 제공), O(1)(상수시간) access, O(1) push_back()
// deque<T> - random access, []연산자, O(1) access, O(1) push_front(), push_back()
// list<T> - O(1) insert, delete, 자료구조를 활용한 전용함수 제공(remove, sort, splice)
// STL의 알고리즘 1.수정X 2.수정O 3.정렬
//-----------------------------------------------------------

#include <iostream>
#include <vector>
#include <deque>
#include <list>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

class Test
{
	char x[1'000'000];
};

int main(){	
	save("메인.cpp");
	{ // 27310
		vector<Test> vec;
		while (true) {
			try
			{
				vec.emplace_back();
			}
			catch (const std::exception& e)
			{
				cout << e.what() << endl;
				cout << "최대 개수 - " << vec.size() << endl;
				break;
			}
		}
	}

	{ // 58802
		deque<Test> vec;
		while (true)
		{
			try
			{
				vec.emplace_back();
			}
			catch (const std::exception& e)
			{
				cout << e.what() << endl;
				cout << "최대 개수 - " << vec.size() << endl;
				break;
			}
		}
	}

	{ // 
		list<Test> vec;
		while (true)
		{
			try
			{
				vec.emplace_back();
			}
			catch (const std::exception& e)
			{
				cout << e.what() << endl;
				cout << "최대 개수 - " << vec.size() << endl;
				break;
			}
		}
	}

}

==========================================
저장한 시간: 2025-05-08 오후 6:12:24 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 08일 목요일				(9주 2일)
// 6/19 목요일 15주 2일 - 기말시험
// 5/12 월요일 - 졸업작품 중간발표수업은 한다.
//-----------------------------------------------------------
// STL Container - Containers are objects that store other objects.
// array<T,N> - 유일하게 크기가 고정
// vector<T> - random access가 가능(== [] 연산자 제공), O(1)(상수시간) access, O(1) push_back()
// deque<T> - random access, []연산자, O(1) access, O(1) push_front(), push_back()
// list<T> - O(1) insert, delete, 자료구조를 활용한 전용함수 제공(remove, sort, splice)
// STL의 알고리즘 1.수정X 2.수정O 3.정렬
//-----------------------------------------------------------

#include <iostream>
#include <vector>
#include <deque>
#include <list>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){	
	deque<int> d{ 1,2,3,4 };

	d.push_front(0);
	d.push_front(-1);
	d.push_back(5);
	d.push_back(6);

	for (int i = 0; i < d.size(); ++i)
	{
		cout << d[i] << " " << addressof(d[i]) << endl;
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-08 오후 6:26:10 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 08일 목요일				(9주 2일)
// 6/19 목요일 15주 2일 - 기말시험
// 5/12 월요일 - 졸업작품 중간발표수업은 한다.
//-----------------------------------------------------------
// STL Container - Containers are objects that store other objects.
// array<T,N> - 유일하게 크기가 고정
// vector<T> - random access가 가능(== [] 연산자 제공), O(1)(상수시간) access, O(1) push_back()
// deque<T> - random access, []연산자, O(1) access, O(1) push_front(), push_back()
// list<T> - O(1) insert, delete, 자료구조를 활용한 전용함수 제공(remove, sort, splice)
// STL의 알고리즘 1.수정X 2.수정O 3.정렬
//-----------------------------------------------------------

#include <iostream>
#include <iterator>
#include <list>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){	
	list<STRING> cont{ "1", "22", "4444", "55555"};

	// [문제] "333"을 추가하라.
	관찰 = true;
	cont.insert( ++ ++ cont.begin(), STRING{ "333" });
	관찰 = false;

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-08 오후 6:27:05 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 08일 목요일				(9주 2일)
// 6/19 목요일 15주 2일 - 기말시험
// 5/12 월요일 - 졸업작품 중간발표수업은 한다.
//-----------------------------------------------------------
// STL Container - Containers are objects that store other objects.
// array<T,N> - 유일하게 크기가 고정
// vector<T> - random access가 가능(== [] 연산자 제공), O(1)(상수시간) access, O(1) push_back()
// deque<T> - random access, []연산자, O(1) access, O(1) push_front(), push_back()
// list<T> - O(1) insert, delete, 자료구조를 활용한 전용함수 제공(remove, sort, splice)
// STL의 알고리즘 1.수정X 2.수정O 3.정렬
//-----------------------------------------------------------

#include <iostream>
#include <iterator>
#include <list>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){	
	list<STRING> cont{ "1", "22", "4444", "55555"};

	// [문제] "333"을 추가하라.
	관찰 = true;
	cont.emplace( ++ ++ cont.begin(), "333");
	관찰 = false;

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-08 오후 6:28:15 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 08일 목요일				(9주 2일)
// 6/19 목요일 15주 2일 - 기말시험
// 5/12 월요일 - 졸업작품 중간발표수업은 한다.
//-----------------------------------------------------------
// STL Container - Containers are objects that store other objects.
// array<T,N> - 유일하게 크기가 고정
// vector<T> - random access가 가능(== [] 연산자 제공), O(1)(상수시간) access, O(1) push_back()
// deque<T> - random access, []연산자, O(1) access, O(1) push_front(), push_back()
// list<T> - O(1) insert, delete, 자료구조를 활용한 전용함수 제공(remove, sort, splice)
// STL의 알고리즘 1.수정X 2.수정O 3.정렬
//-----------------------------------------------------------

#include <iostream>
#include <iterator>
#include <list>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){	
	list<STRING> cont{ "1", "22", "4444", "55555"};

	// [문제] "333"을 추가하라.
	관찰 = true;
	cont.emplace( find(cont.begin(),cont.end(),"4444"), "333");
	관찰 = false;

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-08 오후 6:38:43 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 08일 목요일				(9주 2일)
// 6/19 목요일 15주 2일 - 기말시험
// 5/12 월요일 - 졸업작품 중간발표수업은 한다.
//-----------------------------------------------------------
// STL Container - Containers are objects that store other objects.
// array<T,N> - 유일하게 크기가 고정
// vector<T> - random access가 가능(== [] 연산자 제공), O(1)(상수시간) access, O(1) push_back()
// deque<T> - random access, []연산자, O(1) access, O(1) push_front(), push_back()
// list<T> - O(1) insert, delete, 자료구조를 활용한 전용함수 제공(remove, sort, splice)
// STL의 알고리즘 1.수정X 2.수정O 3.정렬
//-----------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <list>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){	
	// [문제] "메인.cpp"의 단어를 list에 모두 저장하라.

	ifstream in{ "메인.cpp" };
	if (not in)
		return 2021182009;

	list<STRING> words;
	STRING word;

	while (in >> word)
	{
		words.push_back(word);
	}

	for (const STRING& data : words)
	{
		cout << data << endl;
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-08 오후 6:40:43 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 08일 목요일				(9주 2일)
// 6/19 목요일 15주 2일 - 기말시험
// 5/12 월요일 - 졸업작품 중간발표수업은 한다.
//-----------------------------------------------------------
// STL Container - Containers are objects that store other objects.
// array<T,N> - 유일하게 크기가 고정
// vector<T> - random access가 가능(== [] 연산자 제공), O(1)(상수시간) access, O(1) push_back()
// deque<T> - random access, []연산자, O(1) access, O(1) push_front(), push_back()
// list<T> - O(1) insert, delete, 자료구조를 활용한 전용함수 제공(remove, sort, splice)
// STL의 알고리즘 1.수정X 2.수정O 3.정렬
//-----------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <list>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){	
	// [문제] "메인.cpp"의 단어를 list에 모두 저장하라.

	ifstream in{ "메인.cpp" };
	if (not in)
		return 2021182009;

	list<STRING> words{ istream_iterator<STRING>{in},{} };

	for (const STRING& data : words)
		cout << data << endl;

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-08 오후 6:49:29 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 08일 목요일				(9주 2일)
// 6/19 목요일 15주 2일 - 기말시험
// 5/12 월요일 - 졸업작품 중간발표수업은 한다.
//-----------------------------------------------------------
// STL Container - Containers are objects that store other objects.
// array<T,N> - 유일하게 크기가 고정
// vector<T> - random access가 가능(== [] 연산자 제공), O(1)(상수시간) access, O(1) push_back()
// deque<T> - random access, []연산자, O(1) access, O(1) push_front(), push_back()
// list<T> - O(1) insert, delete, 자료구조를 활용한 전용함수 제공(remove, sort, splice)
// STL의 알고리즘 1.수정X 2.수정O 3.정렬
//-----------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <list>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){	
	// [문제] "메인.cpp"의 단어를 list에 모두 저장하라.

	ifstream in{ "메인.cpp" };
	if (not in)
		return 2021182009;

	list<STRING> words{ istream_iterator<STRING>{in},{} };
	vector<STRING> vec{ words.begin(),words.end() };

	관찰 = true;
	words.sort();
	//sort(words.begin(), words.end());
	관찰 = false;

	for (const STRING& data : words)
		cout << data << endl;

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-12 오후 6:52:05 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 12일 월요일				(10주 1일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// STL Container - Containers are objects that store other objects.
// array<T,N> - 유일하게 크기가 고정
// vector<T> - random access가 가능(== [] 연산자 제공), O(1)(상수시간) access, O(1) push_back()
// deque<T> - random access, []연산자, O(1) access, O(1) push_front(), push_back()
// list<T> - O(1) insert, delete, 자료구조를 활용한 전용함수 제공(remove, sort, splice)
// STL의 알고리즘 1.수정X 2.수정O 3.정렬
//-----------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <list>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){	
	save("메인.cpp");

	ifstream in{ "메인.cpp" };
	if (not in)
		return 2021182009;

	list<STRING> words{ istream_iterator<STRING>{in},{} };

	// [문제] 사용자가 입력한 단어가 리스트에 있는 지 알려주자.
	// 단어가 없으면 없다라고 출력하고 있으면 리스트의 몇 번째 단어인지 출력하라.

	while (true)
	{
		cout << "찾을 단어는? ";
		STRING 단어;
		cin >> 단어;

		auto find_word = find(words.begin(), words.end(), 단어);
		if (find_word == words.end())
		{
			cout << "없음" << endl;
		}
		else
		{
			cout << distance(words.begin(), find_word) + 1 << endl;
		}
	}

}

==========================================
저장한 시간: 2025-05-12 오후 7:03:17 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 12일 월요일				(10주 1일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// STL Container - Containers are objects that store other objects.
// array<T,N> - 유일하게 크기가 고정
// vector<T> - random access가 가능(== [] 연산자 제공), O(1)(상수시간) access, O(1) push_back()
// deque<T> - random access, []연산자, O(1) access, O(1) push_front(), push_back()
// list<T> - O(1) insert, delete, 자료구조를 활용한 전용함수 제공(remove, sort, splice)
// STL의 알고리즘 1.수정X 2.수정O 3.정렬
//-----------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <list>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){	
	save("메인.cpp");

	ifstream in{ "메인.cpp" };
	if (not in)
		return 2021182009;

	list<STRING> words{ istream_iterator<STRING>{in},{} };

	// [문제] 단어들에서 길이가 5인 것들만 화면에 출력하라.

	copy(words.begin(), words.end(), ostream_iterator<STRING>{cout} );

	// 다음시간에 다시 코딩하고 반복자 소개에서 시작


}

==========================================
저장한 시간: 2025-05-15 오후 5:40:13 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 15일 목요일				(10주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// STL Container - Containers are objects that store other objects.
// array<T,N> - 유일하게 크기가 고정
// vector<T> - random access가 가능(== [] 연산자 제공), O(1)(상수시간) access, O(1) push_back()
// deque<T> - random access, []연산자, O(1) access, O(1) push_front(), push_back()
// list<T> - O(1) insert, delete, 자료구조를 활용한 전용함수 제공(remove, sort, splice)
// STL의 알고리즘 1.수정X 2.수정O 3.정렬
//-----------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <list>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){	
	save("메인.cpp");

	ifstream in{ "메인.cpp" };
	if (not in)
		return 2021182009;

	list<STRING> words{ istream_iterator<STRING>{in},{} };

	// [문제] 찾을 단어가 있으면 몇 번째인지 출력하라.

	cout << "찾을 단어 머임? ";
	STRING find_word;
	cin >> find_word;

	auto word_place = find(words.begin(), words.end(), find_word);
	if (word_place == words.end()) cout << "없음 ㅅㄱ" << endl;
	else cout << distance(words.begin(), word_place) + 1 << "번째임 ㅅㄱ" << endl;
}

==========================================
저장한 시간: 2025-05-15 오후 6:33:51 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 15일 목요일				(10주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// STL Container - Containers are objects that store other objects.
// array<T,N> - 유일하게 크기가 고정
// vector<T> - random access가 가능(== [] 연산자 제공), O(1)(상수시간) access, O(1) push_back()
// deque<T> - random access, []연산자, O(1) access, O(1) push_front(), push_back()
// list<T> - O(1) insert, delete, 자료구조를 활용한 전용함수 제공(remove, sort, splice)
// forward_list<T> - C스타일의 단일 연결 리스트와 비고해서 공간 혹은 시간상에 오버헤드가 없다. 부가기능이 없기 때문이다.
// STL의 알고리즘 종류 1.수정X 2.수정O 3.정렬
//-----------------------------------------------------------

#include <iostream>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){	
	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-15 오후 7:04:42 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 15일 목요일				(10주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// 부모 -> 자식 : 특수화(specialization) / 자식 -> 부모 : 일반화(generalization)
// 반복자 - Iterators are a generalization of pointers that allow a C++ program to work with different data structures in a uniform manner.
//-----------------------------------------------------------

#include <iostream>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){	
	STRING s{ "2025. 5. 15" };

	// [예고] 오시하력출 로꾸거 를s

	for (char c : s)
	{
		cout << c << " * ";
	}
	cout << endl;
	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-19 오후 6:26:22 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 19일 월요일				(11주 1일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// 부모 -> 자식 : 특수화(specialization) / 자식 -> 부모 : 일반화(generalization)
// 반복자 - Iterators are a generalization of pointers that allow a C++ program to work with different data structures in a uniform manner.
// 역방향 반복자는 반드시 class로만 만들 수 있다.
//-----------------------------------------------------------

#include <iostream>
#include <span>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){	

	STRING s{ "2025. 5. 19" };
	
	// [예고] 오시하력출 로꾸거 를s
	for (auto i = s.rbegin(); i != s.rend(); ++i)
	{
		cout << *i << " ";
	}
	cout << endl;

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-22 오후 5:28:00 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 22일 목요일				(11주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// 반복자 - 각 컨테이너가 자기가 관리하는 원소를 처음부터 끝까지 빠짐없이
// 순회할 수 있도록 제공하는 인터페이스이다.
// 컨테이너에 따라서(자료구조가 서로 다르니까) 반복자로 할 수 있는 일은 서로 다르다.
//-----------------------------------------------------------

#include <iostream>
#include <iterator>
#include "save.h"
#include "STRING.h"

using namespace std;

// 반복자는 서로 다르다 - 6개의 category
// [문제] 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수 f를 정의하라.

void f(const ostream_iterator<char>& p)
{
	cout << typeid(ostream_iterator<char>::iterator_category).name() << endl;
}

int main(){	

	f(ostream_iterator<char>{cout});

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-22 오후 5:49:39 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 22일 목요일				(11주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// 반복자 - 각 컨테이너가 자기가 관리하는 원소를 처음부터 끝까지 빠짐없이
// 순회할 수 있도록 제공하는 인터페이스이다.
// 컨테이너에 따라서(자료구조가 서로 다르니까) 반복자로 할 수 있는 일은 서로 다르다.
//-----------------------------------------------------------

#include <iostream>
#include <iterator>
#include <forward_list>
#include <list>
#include <deque>
#include <vector>
#include "save.h"
#include "STRING.h"

using namespace std;

// 반복자는 서로 다르다 - 6개의 category
// [문제] 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수 f를 정의하라.

template <class 반복자>
void f(const 반복자& p)
{
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;
}

int main(){	

	f(ostream_iterator<char>{cout});
	//f(istream_iterator<int>{cin});

	f(forward_list<char>{}.begin());
	f(list<int>::iterator{});

	deque<STRING> d;
	f(d.rbegin());
	f(vector<int>{}.begin());

	// vector와 deque의 반복자는 random_access_iterator_tag

	int* p;
	f(p);

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-22 오후 5:56:26 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 22일 목요일				(11주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// 반복자 - 각 컨테이너가 자기가 관리하는 원소를 처음부터 끝까지 빠짐없이
// 순회할 수 있도록 제공하는 인터페이스이다.
// 컨테이너에 따라서(자료구조가 서로 다르니까) 반복자로 할 수 있는 일은 서로 다르다.
//-----------------------------------------------------------

#include <iostream>
#include <iterator>
#include <forward_list>
#include <list>
#include <deque>
#include <vector>
#include "save.h"
#include "STRING.h"

using namespace std;

// 반복자는 서로 다르다 - 6개의 category
// [문제] 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수 f를 정의하라.

template <class 반복자>
void f(const 반복자& p)
{
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

	// 벡터라면
	cout << typeid(반복자::iterator_concept).name() << endl;
}

int main(){	
	// vector의 반복자가 contiguous임을 판단하거나 출력하고 싶다.
	f(vector<int>{}.begin());

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-22 오후 5:59:34 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 22일 목요일				(11주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// 반복자 - 각 컨테이너가 자기가 관리하는 원소를 처음부터 끝까지 빠짐없이
// 순회할 수 있도록 제공하는 인터페이스이다.
// 컨테이너에 따라서(자료구조가 서로 다르니까) 반복자로 할 수 있는 일은 서로 다르다.
//-----------------------------------------------------------

#include <iostream>
#include <iterator>
#include <forward_list>
#include <list>
#include <deque>
#include <vector>
#include "save.h"
#include "STRING.h"

using namespace std;

// 반복자는 서로 다르다 - 6개의 category
// [문제] 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수 f를 정의하라.

template <class 반복자>
void f(const 반복자& p)
{
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

	/*if constexpr ( 반복자 == vector )
		cout << typeid(반복자::iterator_concept).name() << endl;*/
}

int main(){	
	// vector의 반복자가 contiguous임을 판단하거나 출력하고 싶다.
	f(deque<int>{}.begin());

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-22 오후 6:24:51 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 22일 목요일				(11주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// 반복자 - 각 컨테이너가 자기가 관리하는 원소를 처음부터 끝까지 빠짐없이
// 순회할 수 있도록 제공하는 인터페이스이다.
// 컨테이너에 따라서(자료구조가 서로 다르니까) 반복자로 할 수 있는 일은 서로 다르다.
//-----------------------------------------------------------

#include <iostream>
#include <iterator>
#include "save.h"
#include "STRING.h"

using namespace std;

// 반복자는 서로 다르다 - 6개의 category
// [문제] 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수 f를 정의하라.

template <class 반복자>
void f(const 반복자& p)
{
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;
}

int main(){	
	STRING s;

	f(s.rbegin());

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-22 오후 6:30:31 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 22일 목요일				(11주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// 반복자 - 각 컨테이너가 자기가 관리하는 원소를 처음부터 끝까지 빠짐없이
// 순회할 수 있도록 제공하는 인터페이스이다.
// 컨테이너에 따라서(자료구조가 서로 다르니까) 반복자로 할 수 있는 일은 서로 다르다.
//-----------------------------------------------------------

#include <iostream>
#include <iterator>
#include "save.h"
#include "STRING.h"

using namespace std;

// 반복자는 서로 다르다 - 6개의 category
// [문제] 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수 f를 정의하라.

template <class 반복자>
void f(const 반복자& p)
{
	cout << typeid(반복자::iterator_category).name() << endl;
}

int main(){	
	STRING s;

	f(s.begin());

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-26 오후 6:19:04 월요일
==========================================

//-------------------------------------------------------------------------------------------------
// STRING.h - STL의 동작을 이해하기 위한 class / std::string과 유사하게 작성
//
// 2025. 4. 10 - 시작
// 2025. 4. 14 - 이동의미론(move semantics) 구현
// 2025. 5. 1 - operator==
// 2025. 5. 15 - begin(), end() 제공
// 2025. 5. 19 - rbegin(), rend() 제공 -> class 아니면 안됨
// 2025. 5. 22 - 반복자가 질문에 응답하도록 한다.
// 2025. 5. 22 - begin(), end()가 반복자를 리턴하도록 한다.
// 2025. 5. 26 - sort가능하도록 필요한 연산자를 모두 코딩
//				(C++ 연산자 오버로딩을 잘 이해해야 할 수 있다.)
//-------------------------------------------------------------------------------------------------
#pragma once
#include <iostream>
#include <memory>

// Iterator adaptor - 반복자의 인터페이스를 제공하지만 실제는 다르게 동작
// 표준반복자가 제공해야할 다섯가지 타입을 제공한다.


class STRING_Reverse_Iterator {
public:
	using difference_type = std::ptrdiff_t;
	using value_type = char;
	using pointer = char*;
	using reference = char&;
	using iterator_category = std::random_access_iterator_tag;

public:
	explicit STRING_Reverse_Iterator(char* p) : p{ p } { }; // explicit -> 자동 형변환 막기
	
	// 반복자라면 제공해야할 기본동작이 있다.
	void operator++(){
		--p;
	}

	char operator*() const
	{
		return *(p - 1);
	}

	bool operator==(const STRING_Reverse_Iterator& rhs) const
	{
		return p == rhs.p;
	}
private:
	char* p;
};

class STRING_Iterator
{
public:
	using difference_type = std::ptrdiff_t;
	using value_type = char;
	using pointer = char*;
	using reference = char&;
	using iterator_category = std::random_access_iterator_tag;

public:
	// 2025. 5. 26 special 함수인 default ctor를 요구
	STRING_Iterator() = default;

	STRING_Iterator(char* p) : p{ p } {};

	// 이건 의미를 제대로 코딩해야 한다.
	// 2025. 5. 26 수정 - 자기 자신을 리턴해야한다.
	STRING_Iterator& operator++()
	{
		++p;
		return *this;
	}

	// 2025. 5. 26 수정
	// 원래는 리턴값이 l-value가 아님 -> &를 리턴하고 const를 제거함
	char& operator*()
	{
		return *p;
	}

	// cv-qualifier는 오버로딩으로 구분 가능하다.
	char& operator*() const
	{
		return *p;
	}
	
	// <=> 작성 후 주석처리 -> 우주선 연산의 뭔가뭔가로 다시 살림
	bool operator==(const STRING_Iterator& rhs) const
	{
		return p == rhs.p;
	}

	// sort가 동작하도록 필요 연산자 추가
	// 2025. 5. 26
	difference_type operator-(const STRING_Iterator& rhs) const
	{
		return p - rhs.p;	// 연산의 결과가 클래스의 불변성(invariants)을 해치나 관찰
	}

	STRING_Iterator& operator--()
	{
		--p;
		return *this;
	}

	// 모든 relational operation을 할 수 있게 <=>를 정의해 본다.
	// <, <=, ==, !=, >=, > ==압축=> <=>
	auto operator<=>(const STRING_Iterator& rhs) const
	{
		return p <=> rhs.p;
	}

	STRING_Iterator operator+(difference_type n) const
	{
		return p + n;
	}

	STRING_Iterator operator-(difference_type n) const
	{
		return p - n;
	}

private:
	char* p{}; // = nullptr;
};

class STRING {
public:
	STRING();
	~STRING();
	
	STRING(const char* str);	// 생성자

	// 복사생성자와 복사할당연산자 2025. 4. 10
	STRING(const STRING&);
	STRING& operator=(const STRING&);

	// 이동생성자와 이동할당연산자 2025. 4. 14
	STRING(STRING&&);
	STRING& operator=(STRING&&);

	// 기본정렬을 위한 < 2025. 4. 14
	// 사전식정렬하도록 수정 - 2025. 5. 15
	bool operator<(const STRING&) const;

	// 같은 객체인지 비교 == - 2025. 5. 1 
	bool operator==(const STRING&) const;

	size_t size() const;

	// 2025. 5. 15
	STRING_Iterator begin() const;
	STRING_Iterator end() const;

	// 2025. 5. 19
	STRING_Reverse_Iterator rbegin() const;
	STRING_Reverse_Iterator rend() const;

private:
	size_t num{};
	std::unique_ptr<char[]> p{};

	size_t id;				// 2025. 4. 10 관찰을 위한 객체 고유번호

	friend std::ostream& operator<<(std::ostream&, const STRING&);

	friend std::istream& operator>>(std::istream&, STRING&);	// 2025. 4. 14

	static size_t gid;		// 2025. 4. 10 고유번호 생성
};


==========================================
저장한 시간: 2025-05-26 오후 6:19:04 월요일
==========================================

//-------------------------------------------------------------------------------------------------
// STRING.cpp - STL의 동작을 이해하기 위한 class / std::string과 유사하게 작성
//
// 2025. 4. 10 - 시작
// 2025. 4. 10 - 복사생성/복사할당연산자, 스페셜 함수의 동작 관찰
// 2025. 4. 14 - 선택적 관찰하도록 전역변수를 사용, 이동의미론(move semantics) 구현
// 2025. 5. 1 - operator==
// 2025. 5. 15 - std::string과 같이 사전식 정렬하도록 수정
// 2025. 5. 15 - begin(), end()
// 2025. 5. 19 - rbegin(), rend()
//-------------------------------------------------------------------------------------------------
#include <memory>
#include <print>
#include <algorithm>
#include "STRING.h"

size_t STRING::gid{ 0 };		// 2025. 4. 10 고유번호 생성
bool 관찰{ false };

STRING::STRING()
	: id{ ++gid }
{
	if (관찰)
	{
		std::println("[{:6}] {:<16} 자원수:{:4}, 주소:{:16} 자원의주소:{:16}",
			id, "디폴트생성", num, (void*)this, (void*)p.get());
	}
}

STRING::~STRING()
{
	if (관찰)
	{
		std::println("[{:6}] {:<16} 자원수:{:4}, 주소:{:16} 자원의주소:{:16}",
			id, "소멸자", num, (void*)this, (void*)p.get());
	}
}

STRING::STRING(const char* str) 
	: num{ strlen(str) }, id{ ++gid }
{
	p.release();
	p = std::make_unique<char[]>(num);
	memcpy(p.get(), str, num);

	if (관찰)
	{
		std::println("[{:6}] {:<16} 자원수:{:4}, 주소:{:16} 자원의주소:{:16}",
			id, "생성자(char*)", num, (void*)this, (void*)p.get());
	}
};

// 복사생성자와 복사할당연산자 2025. 4. 10
STRING::STRING(const STRING& other)	// 복사 생성은 할당을 이용해서 코딩하라
	:num{ other.num }, id{ ++gid }
{
	p = std::make_unique<char[]>(num);
	memcpy(p.get(), other.p.get(), num);

	if (관찰)
	{
		std::println("[{:6}] {:<16} 자원수:{:4}, 주소:{:16} 자원의주소:{:16}",
			id, "복사생성자", num, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(const STRING& other)
{
	if (this == &other) return *this; // [int* p = &a] => address of /// [int& r = a] => reference

	num = other.num;

	p.release();
	p = std::make_unique<char[]>(num);
	memcpy(p.get(), other.p.get(), num);

	if (관찰)
	{
		std::println("[{:6}] {:<16} 자원수:{:4}, 주소:{:16} 자원의주소:{:16}",
			id, "copy operator=", num, (void*)this, (void*)p.get());
	}

	return *this;
}

STRING::STRING(STRING&& other)
	: num{ other.num }, id{ ++gid }
{
	p.reset(other.p.release());

	//other.num = 0;

	if (관찰)
	{
		std::println("[{:6}] {:<16} 자원수:{:4}, 주소:{:16} 자원의주소:{:16}",
			id, "이동생성자", num, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(STRING&& other)
{
	if (this == &other)
		return *this;

	num = other.num;
	p.release();
	p.reset(other.p.release());

	//other.num = 0;

	if (관찰)
	{
		std::println("[{:6}] {:<16} 자원수:{:4}, 주소:{:16} 자원의주소:{:16}",
			id, "move operator=", num, (void*)this, (void*)p.get());
	}

	return *this;
}

// 기본정렬을 위한 < 2025. 4. 14
// 사전식정렬하도록 수정 - 2025. 5. 15
bool STRING::operator<(const STRING& rhs) const
{
	return std::lexicographical_compare(p.get(), p.get() + num, &rhs.p[0], &rhs.p[rhs.num]);
}

// 같은 객체인지 비교 == - 2025. 5. 1 
bool STRING::operator==(const STRING& rhs) const
{
	return std::equal(p.get(), p.get() + num, &rhs.p[0], &rhs.p[rhs.num]);
}

size_t STRING::size() const 
{
	return num;
};

// 2025. 5. 15
STRING_Iterator STRING::begin() const
{
	return STRING_Iterator(&p[0]); // p.get();
}

STRING_Iterator STRING::end() const
{
	return STRING_Iterator(&p[num]); // p.get() + num;
}


// 2025. 5. 19
STRING_Reverse_Iterator STRING::rbegin() const
{
	
	return STRING_Reverse_Iterator(&p[num]);
}

STRING_Reverse_Iterator STRING::rend() const
{
	return STRING_Reverse_Iterator(&p[0]);
}

std::ostream& operator<<(std::ostream& os, const STRING& s)
{
	for (int i = 0; i < s.num; ++i) {
		os << s.p[i];
	}
	return os;
}

std::istream& operator>>(std::istream& is, STRING& s)	// 2025. 4. 14
{
	std::string str;
	is >> str;

	s.num = str.size();
	s.p.release();
	s.p = std::make_unique<char[]>(s.num);
	memcpy(s.p.get(), str.data(), s.num);

	return is;
}

==========================================
저장한 시간: 2025-05-26 오후 6:19:04 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 26일 월요일				(12주 1일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// 반복자 - 각 컨테이너가 자기가 관리하는 원소를 처음부터 끝까지 빠짐없이
// 순회할 수 있도록 제공하는 인터페이스이다.
// 컨테이너에 따라서(자료구조가 서로 다르니까) 반복자로 할 수 있는 일은 서로 다르다.
//-----------------------------------------------------------

#include <iostream>
#include <string>
#include <algorithm>
#include "save.h"
#include "STRING.h"

using namespace std;

template <class 반복자>
void f(const 반복자& p)
{
	cout << typeid(반복자::iterator_category).name() << endl;
}

int main(){	
	STRING s{ "the quick brown fox jumps over the lazy dog" };

	// 알고리즘 sort는 랜덤반복자를 전달받는다.
	// 따라서 s.begin()과 s.end()는 랜덤반복자가 지원해야만 하는 모든 연산을 제공하여야 한다. - 이렇게 하는 것이 원칙이다.
	// 이 수업에서는 sort가 필요로하는 연산자만 만든다.

	sort(s.begin(), s.end());

	cout << s << endl;	

	save("STRING.h");
	save("STRING.cpp");
	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-26 오후 6:28:23 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 26일 월요일				(12주 1일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// 반복자와 알고리즘 함수
// find()
// find_if()
// copy()
//-----------------------------------------------------------

#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"

using namespace std;

int main(){	
	STRING s{ "2025. 5. 26" };

	// [문제] 한 글자를 입력받아 s에 있는지 없는지, 있다면 몇번째 글자인지 출력하라.

	cout << "찾을 문자를 입력하 :";
	char inputchar;
	cin >> inputchar;

	auto location = find(s.begin(), s.end(), inputchar);
	if (location != s.end())
	{
		/*
		// 만일 random_access_iterator_tag라면 위치는 
		cout << location - s.begin() + 1 << "번째에 문자입니다." << endl;
		// 아니라면 개수를 세 나아가야 한다.
		*/
		// 위와 같은 일을 하는 것이 distance 함수이다.
		cout << distance(s.begin(), location) + 1 << "번째 문자입니다." << endl;
	}
	else
	{
		cout << "없음" << endl;
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-26 오후 6:47:26 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 26일 월요일				(12주 1일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// 반복자와 알고리즘 함수
// find()
// find_if()
// copy()
//-----------------------------------------------------------

#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"

using namespace std;

template <class 반복자, class 찾을값>
반복자 my_find(반복자 begin, 반복자 end, 찾을값 val)
{
	while (begin != end)
	{
		if (*begin == val)
			return begin;
		++begin;
	}

	return begin;
}

int main(){	
	STRING s{ "2025. 5. 26" };

	// [문제] 한 글자를 입력받아 s에 있는지 없는지, 있다면 몇번째 글자인지 출력하라.

	cout << "찾을 문자를 입력하 :";
	char inputchar;
	cin >> inputchar;
	
	auto location = my_find(s.begin(), s.end(), inputchar);
	if (location != s.end())
	{
		/*
		// 만일 random_access_iterator_tag라면 위치는 
		cout << location - s.begin() + 1 << "번째에 문자입니다." << endl;
		// 아니라면 개수를 세 나아가야 한다.
		*/
		// 위와 같은 일을 하는 것이 distance 함수이다.
		cout << distance(s.begin(), location) + 1 << "번째 문자입니다." << endl;
	}
	else
	{
		cout << "없음" << endl;
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-26 오후 6:59:16 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 26일 월요일				(12주 1일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// 반복자와 알고리즘 함수
// find()
// find_if()
// copy()
//-----------------------------------------------------------

#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"

using namespace std;

template <class 반복자, class 찾을값>
반복자 my_find(반복자 begin, 반복자 end, 찾을값 val)
{
	while (begin != end)
	{
		if (*begin == val)
			return begin;
		++begin;
	}

	return begin;
}

template <class 반복자, class 호출가능타입>
반복자 my_find_if(반복자 begin, 반복자 end, 호출가능타입 callable)
{
	while (begin != end)
	{
		if (callable(*begin) == true)
			return begin;
		++begin;
	}

	return begin;
}

int main(){	
	STRING s{ "2025. 5. 26" };

	// [문제] 

	auto p = my_find_if(s.begin(), s.end(), [](char c)
		{
			return '3' < c;
		});

	if (p != s.end())
	{
		cout << "3보다 큰 " << *p << "를 찾았다." << endl;
	}
	else
	{
		cout << "3보다 큰 수는 없다." << endl;
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-26 오후 7:01:52 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 26일 월요일				(12주 1일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// 반복자와 알고리즘 함수
// find()
// find_if()
// copy()
//-----------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <vector>
#include "save.h"
#include "STRING.h"

using namespace std;

template <class 반복자, class 찾을값>
반복자 my_find(반복자 begin, 반복자 end, 찾을값 val)
{
	while (begin != end)
	{
		if (*begin == val)
			return begin;
		++begin;
	}

	return begin;
}

template <class 반복자, class 호출가능타입>
반복자 my_find_if(반복자 begin, 반복자 end, 호출가능타입 callable)
{
	while (begin != end)
	{
		if (callable(*begin) == true)
			return begin;
		++begin;
	}

	return begin;
}

int main(){	
	STRING s{ "2025. 5. 26" };

	// [문제] s가 관리하는 문자들을 화면에 출력하라(복사하라).

	copy(s.begin(), s.end(), ostream_iterator<char>{cout});

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-29 오후 5:29:07 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 29일 목요일				(12주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// 반복자와 알고리즘 함수
// find()
// find_if()
// copy()
//-----------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <vector>
#include "save.h"
#include "STRING.h"

using namespace std;

template <class 반복자, class 찾을값>
반복자 my_find(반복자 begin, 반복자 end, 찾을값 val)
{
	while (begin != end)
	{
		if (*begin == val)
			return begin;
		++begin;
	}

	return begin;
}

template <class 반복자, class 호출가능타입>
반복자 my_find_if(반복자 begin, 반복자 end, 호출가능타입 callable)
{
	while (begin != end)
	{
		if (callable(*begin) == true)
			return begin;
		++begin;
	}

	return begin;
}

int main(){	
	STRING s{ "2025. 5. 26" };
	vector<char> v( s.size() );

	// [문제] s가 관리하는 문자들을 화면에 출력하라(복사하라).

	copy(s.begin(), s.end(), v.begin()); // 즉사하는 이유 => v가 저장 가능한 양보다 많음

	for (const char& a : v)
	{
		cout << a;
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-29 오후 5:40:04 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 29일 목요일				(12주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// 반복자와 알고리즘 함수
// find()
// find_if()
// copy()
//-----------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <vector>
#include "save.h"
#include "STRING.h"

using namespace std;

template <class 반복자, class 찾을값>
반복자 my_find(반복자 begin, 반복자 end, 찾을값 val)
{
	while (begin != end)
	{
		if (*begin == val)
			return begin;
		++begin;
	}

	return begin;
}

template <class 반복자, class 호출가능타입>
반복자 my_find_if(반복자 begin, 반복자 end, 호출가능타입 callable)
{
	while (begin != end)
	{
		if (callable(*begin) == true)
			return begin;
		++begin;
	}

	return begin;
}

template <class 반복자>
void my_copy(반복자 begin, 반복자 end, 반복자 dest)
{

}

int main(){	
	STRING s{ "2025. 5. 29" };
	vector<char> v;

	v.reserve(s.size());
	v.resize(s.size());

	// [문제] s가 관리하는 문자들을 화면에 출력하라(복사하라).

	copy(s.begin(), s.end(), v.begin()); // 즉사하는 이유 => v가 저장 가능한 양보다 많음

	cout << "capacity :" << v.capacity() << endl;
	cout << "size :" << v.size() << endl;
	

	for (const char& a : v)
	{
		cout << a << "-";
	}
	cout << endl;

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-29 오후 5:47:36 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 29일 목요일				(12주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// 반복자와 알고리즘 함수
// find()
// find_if()
// copy()
//-----------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <vector>
#include "save.h"
#include "STRING.h"

using namespace std;

template <class 반복자, class 찾을값>
반복자 my_find(반복자 begin, 반복자 end, 찾을값 val)
{
	while (begin != end)
	{
		if (*begin == val)
			return begin;
		++begin;
	}

	return begin;
}

template <class 반복자, class 호출가능타입>
반복자 my_find_if(반복자 begin, 반복자 end, 호출가능타입 callable)
{
	while (begin != end)
	{
		if (callable(*begin) == true)
			return begin;
		++begin;
	}

	return begin;
}

template <class 원본,class 복사본>
void my_copy(원본 begin, 원본 end, 복사본 dest)
{
	while (begin not_eq end)
	{
		*dest = *begin;
		++dest;
		++begin;
	}
}

int main(){	
	STRING s{ "2025. 5. 29" };

	// [문제] s가 관리하는 문자들을 화면에 출력하라(복사하라).

	my_copy(s.begin(), s.end(), ostream_iterator<char>{cout});
	cout << endl;

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-29 오후 6:07:54 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 29일 목요일				(12주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// 반복자와 알고리즘 함수
// find()
// find_if()
// copy()
//-----------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <vector>
#include "save.h"
#include "STRING.h"

using namespace std;

template <class 반복자, class 찾을값>
반복자 my_find(반복자 begin, 반복자 end, 찾을값 val)
{
	while (begin != end)
	{
		if (*begin == val)
			return begin;
		++begin;
	}

	return begin;
}

template <class 반복자, class 호출가능타입>
반복자 my_find_if(반복자 begin, 반복자 end, 호출가능타입 callable)
{
	while (begin != end)
	{
		if (callable(*begin) == true)
			return begin;
		++begin;
	}

	return begin;
}

template <class 원본,class 복사본>
void my_copy(원본 begin, 원본 end, 복사본 dest)
{
	while (begin not_eq end)
	{
		*dest = *begin; // v.push_back(*b)
		++dest;			// 아무것도 안한다.
		++begin;
	}
}

int main(){	
	STRING s{ "2025. 5. 29" };

	vector<char> v;
	v.reserve(s.size());

	// [문제] s가 관리하는 문자를 vector에 복사).

	my_copy(s.begin(), s.end(), back_inserter(v));

	for (const char& c : v)
	{
		cout << c;
	}
	//for (int i = 0; i < s.size(); ++i)
	//{
	//	cout << v[i];
	//}
	cout << endl;

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-29 오후 6:17:16 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 29일 목요일				(12주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// STL
// 1. 컨테이너 -> sequence / Associative / Unordered Associative
// 2. Iterator
// 3. 알고리즘 -> Non-Modifying / Modifying / Sorting & Related
//-----------------------------------------------------------

#include <iostream>
#include "save.h"
#include "STRING.h"

using namespace std;

int main(){	

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-29 오후 6:45:53 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 29일 목요일				(12주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// Associative Container
// - set<key>			: key와 value를 구분하지 않는다.
// - Map<key, value>	: <아이돌그룹, 멤버>
//-----------------------------------------------------------

#include <iostream>
#include <set>
#include "save.h"
#include "STRING.h"

using namespace std;

// set<key, less<key>>;
// key를 less<key>를 사용하여 항상 정렬 상태로 유지
//
// 이때 ->	equivalence(동등성) a와b는 동등하다: !(a<b) && !(b<a)
//			
//			equality(상등성) a와 b는 상등하다: a==b

int main(){	
	save("메인.cpp");
}

==========================================
저장한 시간: 2025-05-29 오후 7:06:43 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 5월 29일 목요일				(12주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// Associative Container
// - set<key>			: key와 value를 구분하지 않는다.
// - Map<key, value>	: <아이돌그룹, 멤버>
//-----------------------------------------------------------

#include <iostream>
#include <fstream>
#include <vector>
#include <set>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] "이상한 나라의 앨리스.txt"를 다운받는다.
// [1] vector<STRING> v; 에 저장하라.
// [2] 모두 몇 단어로 만들었는지 출력하라.

int main(){	
	ifstream Alice{ "이상한 나라의 앨리스.txt" };
	if (not Alice)
	{
		cout << "파일이 없다." << endl;
		return 18651126;
	}

	//vector<STRING> v;
	//v.reserve(30000);
	// 값을 바꿔 꼭 비교해 보세요. =(개인)> reserve가 단어수 이상이 되면 불필요한 STRING생성이 없다.

	set<STRING> v{ istream_iterator<STRING>{Alice},{} }; // vector에서는 STRING의 생성이 엄청나다. but Associative 컨테이너에서는 부담이 없다.

	//STRING in;
	//while (Alice >> in)
	//{
	//	v.push_back(in);
	//}

	cout << "단어의 개수 :" << v.size() << endl;

	save("메인.cpp");
	관찰 = true;
}

==========================================
저장한 시간: 2025-06-02 오후 5:48:31 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 2일 월요일				(13주 1일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// Associative Container
// - set<key>			: key와 value를 구분하지 않는다.
// - Map<key, value>	: <아이돌그룹, 멤버>
//-----------------------------------------------------------

#include <iostream>
#include <fstream>
#include <set>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;


// [문제] "이상한 나라의 앨리스.txt"를 다운받는다.
// [1] set<STRING> s; 에 저장하라.
// [2] 모두 몇 단어로 만들었는지 출력하라.

template <>
struct less<STRING>
{
	bool operator()(const STRING& lhs, const STRING& rhs) const
	{
		return lhs.size() < rhs.size();
	}
};

int main(){	
	ifstream Alice{ "이상한 나라의 앨리스.txt" };
	if (not Alice)
	{
		cout << "파일이 없다." << endl;
		return 18651126;
	}

	// 기본 operator< 가 정의되어 있는 객체라면 원소로 관리가능하다. 
	set<STRING> s{ istream_iterator<STRING>{Alice},{} };

	// 이때 사용자 정의 자료형 STRING을 저장하는 set은
	// 1. less<STRING>을 찾는다.
	// 2. operator<를 찾는다.

	cout << "단어의 개수 :" << s.size() << endl;

	for (const STRING& words : s)
	{
		cout << words << endl;
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-06-02 오후 6:44:15 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 2일 월요일				(13주 1일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// Associative Container
// - set<key>			: key와 value를 구분하지 않는다.
// - Map<key, value>	: <아이돌그룹, 멤버>
//-----------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <set>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;


// [문제] "이상한 나라의 앨리스.txt"를 다운받는다.
// [1] set<STRING> s; 에 저장하라.
// [2] 모두 몇 단어로 만들었는지 출력하라.

//template <>
//struct less<STRING>
//{
//	bool operator()(const STRING& lhs, const STRING& rhs) const
//	{
//		return lhs.size() < rhs.size();
//	}
//};

int main(){
	save("메인.cpp");

	ifstream Alice{ "이상한 나라의 앨리스.txt" };
	if (not Alice)
	{
		cout << "파일이 없다." << endl;
		return 18651126;
	}

	// 기본 operator< 가 정의되어 있는 객체라면 원소로 관리가능하다. 
	multiset<STRING> s{ istream_iterator<STRING>{Alice},{} };

	// 이때 사용자 정의 자료형 STRING을 저장하는 set은
	// 1. less<STRING>을 찾는다.
	// 2. operator<를 찾는다.

	cout << "ㄷㅏㄴㅇㅓㅇㅡㅣ ㄱㅐㅅㅜ :" << s.size() << endl;

	// [문제] 단어를 입력받아서 소설에 있는 단어인지 알려주자.

	for (const STRING& word : s)
	{
		cout << word << " ";
	}

	cout << endl;

	while (true)
	{
		cout << "ㅇㅣㅂㄹㅕㄱ ㄷㅏㄴㅇㅓ : ";
		STRING input;
		cin >> input;

		cout << "ㅇㅣㅂㄹㅕㄱㅎㅏㄴ ㄷㅏㄴㅇㅓㅇㅡㅣ ㄱㅐㅅㅜㄴㅡㄴ" << s.count(input) << endl;
		// 이건 다음 코드를 포장한 것이다.

		pair<multiset<STRING>::const_iterator,
			multiset<STRING>::const_iterator> finded_range = s.equal_range(input);
		cout << distance(finded_range.first, finded_range.second) << endl;

		//auto finded = s.find(input);

		//if (finded != s.end())
		//{
		//	cout << "ㅇㅜㅣㅊㅣㄴㅡㄴ " << distance(s.begin(), finded) + 1 << endl;
		//}
		//else
		//{
		//	cout << "ㅇㅓㅂㅅㄴㅡㄴ ㄷㅏㄴㅇㅓ" << endl;
		//}
		
	}

}

==========================================
저장한 시간: 2025-06-02 오후 6:45:54 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 2일 월요일				(13주 1일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// Associative Container
// - set<key>			: key와 value를 구분하지 않는다.
// - Map<key, value>	: <아이돌그룹, 멤버>
//-----------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <set>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;


// [문제] "이상한 나라의 앨리스.txt"를 다운받는다.
// [1] set<STRING> s; 에 저장하라.
// [2] 모두 몇 단어로 만들었는지 출력하라.

//template <>
//struct less<STRING>
//{
//	bool operator()(const STRING& lhs, const STRING& rhs) const
//	{
//		return lhs.size() < rhs.size();
//	}
//};

int main(){
	save("메인.cpp");

	ifstream Alice{ "이상한 나라의 앨리스.txt" };
	if (not Alice)
	{
		cout << "파일이 없다." << endl;
		return 18651126;
	}

	// 기본 operator< 가 정의되어 있는 객체라면 원소로 관리가능하다. 
	multiset<STRING> s{ istream_iterator<STRING>{Alice},{} };

	// 이때 사용자 정의 자료형 STRING을 저장하는 set은
	// 1. less<STRING>을 찾는다.
	// 2. operator<를 찾는다.

	cout << "ㄷㅏㄴㅇㅓㅇㅡㅣ ㄱㅐㅅㅜ :" << s.size() << endl;

	// [문제] 단어를 입력받아서 소설에 있는 단어인지 알려주자.

	for (const STRING& word : s)
	{
		cout << word << " ";
	}

	cout << endl;

	while (true)
	{
		cout << "ㅇㅣㅂㄹㅕㄱ ㄷㅏㄴㅇㅓ : ";
		STRING input;
		cin >> input;

		cout << "ㅇㅣㅂㄹㅕㄱㅎㅏㄴ ㄷㅏㄴㅇㅓㅇㅡㅣ ㄱㅐㅅㅜㄴㅡㄴ" << s.count(input) << endl;
		// 이건 다음 코드를 포장한 것이다.

		auto[하한,상한] = s.equal_range(input);
		cout << distance(하한, 상한) << endl;

		//auto finded = s.find(input);

		//if (finded != s.end())
		//{
		//	cout << "ㅇㅜㅣㅊㅣㄴㅡㄴ " << distance(s.begin(), finded) + 1 << endl;
		//}
		//else
		//{
		//	cout << "ㅇㅓㅂㅅㄴㅡㄴ ㄷㅏㄴㅇㅓ" << endl;
		//}
		
	}

}

==========================================
저장한 시간: 2025-06-05 오후 5:33:14 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 5일 목요일				(13주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// Associative Container
// - set<key>			: key와 value를 구분하지 않는다.
// - Map<key, value>	: <아이돌그룹, 멤버>
//-----------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <set>
#include <map>
#include <array>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){

	ifstream Alice{ "이상한 나라의 앨리스.txt" };
	if (not Alice)
	{
		cout << "파일이 없다." << endl;
		return 18651126;
	}

	multiset<STRING> s{ istream_iterator<STRING>{Alice},{} };
	cout << "ㄷㅏㄴㅇㅓㅇㅡㅣ ㄱㅐㅅㅜ :" << s.size() << endl;

	// [문제] multiset<STRING> 
	// 모든 알파벳의 사용횟수를 다음과 같이
	// 알파벳과 사용된 횟수기준 내림차순으로 출력하라
	// 대문자는 소문자로 바꾸자
	// e - 13618
	// t - 10726
	// ...
	// z - 78

	map<char, size_t> m;

	for (const STRING& word : s)
	{
		for (char& alpha : word)
		{
			if (isalpha(alpha))
			{
				tolower(alpha);
				m[alpha]++;
			}
		}
	}

	for (pair<char, size_t> p : m)
	{
		cout << p.first << " - " << p.second << endl;
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-06-05 오후 5:33:21 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 5일 목요일				(13주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// Associative Container
// - set<key>			: key와 value를 구분하지 않는다.
// - Map<key, value>	: <아이돌그룹, 멤버>
//-----------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <set>
#include <map>
#include <array>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){

	ifstream Alice{ "이상한 나라의 앨리스.txt" };
	if (not Alice)
	{
		cout << "파일이 없다." << endl;
		return 18651126;
	}

	multiset<STRING> s{ istream_iterator<STRING>{Alice},{} };
	cout << "ㄷㅏㄴㅇㅓㅇㅡㅣ ㄱㅐㅅㅜ :" << s.size() << endl;

	// [문제] multiset<STRING> 
	// 모든 알파벳의 사용횟수를 다음과 같이
	// 알파벳과 사용된 횟수기준 내림차순으로 출력하라
	// 대문자는 소문자로 바꾸자
	// e - 13618
	// t - 10726
	// ...
	// z - 78

	map<char, size_t> m;

	for (const STRING& word : s)
	{
		for (char& alpha : word)
		{
			if (isalpha(alpha))
			{
				m[tolower(alpha)]++;
			}
		}
	}

	for (pair<char, size_t> p : m)
	{
		cout << p.first << " - " << p.second << endl;
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-06-05 오후 5:51:18 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 5일 목요일				(13주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// Associative Container
// - set<key>			: key와 value를 구분하지 않는다.
// - Map<key, value>	: <아이돌그룹, 멤버>
//-----------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <set>
#include <map>
#include <array>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){

	ifstream Alice{ "이상한 나라의 앨리스.txt" };
	if (not Alice)
	{
		cout << "파일이 없다." << endl;
		return 18651126;
	}

	multiset<STRING> s{ istream_iterator<STRING>{Alice},{} };

	// [문제] multiset<STRING> 
	// 모든 알파벳의 사용횟수를 다음과 같이
	// 알파벳과 사용된 횟수기준 내림차순으로 출력하라
	// 대문자는 소문자로 바꾸자
	// e - 13618
	// t - 10726
	// ...
	// z - 78

	map<char, size_t> m;

	for (const STRING& word : s)
	{
		for (char& alpha : word)
		{
			if (isalpha(alpha))
			{
				m[tolower(alpha)]++;
			}
		}
	}

	// 개수 기준 내림차순으로 출력한다.
	map<size_t, char, greater<size_t>> w;

	for (auto& [ch,count] : m)
	{
		w[count] = ch;
	}


	for (const auto& [count,ch] : w)
	{
		cout << ch << " - " << count << endl;
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-06-05 오후 6:12:56 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 5일 목요일				(13주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// Associative Container
// - set<key>			: key와 value를 구분하지 않는다.
// - Map<key, value>	: <아이돌그룹, 멤버>
//-----------------------------------------------------------

#include <iostream>
#include <fstream>
#include <map>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){

	ifstream Alice{ "이상한 나라의 앨리스.txt" };
	if (not Alice)
	{
		cout << "파일이 없다." << endl;
		return 18651126;
	}

	// [문제] 소설에 사용된 단어의 출현횟수를 알고 싶다.
	// 다음과 같은 형식으로 출력해보자.
	// 
	// the -1500
	// a - 1000
	// ...
	// zigzag - 1

	map<STRING, size_t> m;
	STRING word;
	while (Alice >> word)
	{
		m[word]++;
	}

	// 많이 사용된 단어순으로 출력되도록 하자
	map<size_t, STRING,greater<size_t>> w;
	for (const auto& [wor, cou] : m)
	{
		w[cou] = wor;
	}

	for (const auto& [c, w] : w)
	{
		cout << w << " - " << c << endl;
	}


	save("메인.cpp");
}

==========================================
저장한 시간: 2025-06-05 오후 6:19:29 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 5일 목요일				(13주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// Associative Container
// - set<key>			: key와 value를 구분하지 않는다.
// - Map<key, value>	: <아이돌그룹, 멤버>
//-----------------------------------------------------------

#include <iostream>
#include <fstream>
#include <map>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){

	ifstream Alice{ "이상한 나라의 앨리스.txt" };
	if (not Alice)
	{
		cout << "파일이 없다." << endl;
		return 18651126;
	}

	// [문제] 소설에 사용된 단어의 출현횟수를 알고 싶다.
	// 다음과 같은 형식으로 출력해보자.
	// 
	// the -1500
	// a - 1000
	// ...
	// zigzag - 1

	map<STRING, size_t> m;
	STRING word;
	while (Alice >> word)
	{
		m[word]++;
	}

	// 많이 사용된 단어순으로 출력되도록 하자
	multimap<size_t, STRING,greater<size_t>> w;
	for (const auto& [wor, cou] : m)
	{
		//w[cou] = wor; - unique key일때만 허용되는 sugar
		w.insert(pair<size_t,STRING>{cou,wor});	// 정식
		w.insert(make_pair(cou, wor)); // 편의함수 사용
	}

	for (const auto& [c, w] : w)
	{
		cout << w << " - " << c << endl;
	}


	save("메인.cpp");
}

==========================================
저장한 시간: 2025-06-05 오후 6:42:28 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 5일 목요일				(13주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// Associative Container
// - set<key>			: key와 value를 구분하지 않는다.
// - Map<key, value>	: <아이돌그룹, 멤버>
//-----------------------------------------------------------

#include <iostream>
#include <map>
#include <random>
#include <array>
#include <print>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] uniform 분포는 uniform 한가?
// [문제] normal 분포는 normal한가?

default_random_engine dre;	// mt19937 엔진
uniform_int_distribution uid{ 0,99'9999 };
normal_distribution nd;


array<int, 2025'0605> a;

int main(){
	for (int& num : a)
	{
		double d = nd(dre);
		d *= 50'0000;
		d += 50'0000;

		if (0 <= d && d < 100'0000)
		{
			num = (int)d;
		}

	}
	
	map<int, size_t> 구간_개수;

	for (const int& num : a)
	{
		구간_개수[num / 5'0000]++;
	}

	for (const auto& [구간, 개수] : 구간_개수)
	{
		println("[{:>2}] - {}", 구간, 개수);
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-06-05 오후 6:42:47 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 5일 목요일				(13주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// Associative Container
// - set<key>			: key와 value를 구분하지 않는다.
// - Map<key, value>	: <아이돌그룹, 멤버>
//-----------------------------------------------------------

#include <iostream>
#include <map>
#include <random>
#include <array>
#include <print>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] uniform 분포는 uniform 한가?
// [문제] normal 분포는 normal한가?

default_random_engine dre;	// mt19937 엔진
uniform_int_distribution uid{ 0,99'9999 };
normal_distribution nd;


array<int, 2025'0605> a;

int main(){
	for (int& num : a)
	{
		double d = nd(dre);
		d *= 20'0000;
		d += 50'0000;

		if (0 <= d && d < 100'0000)
		{
			num = (int)d;
		}

	}
	
	map<int, size_t> 구간_개수;

	for (const int& num : a)
	{
		구간_개수[num / 5'0000]++;
	}

	for (const auto& [구간, 개수] : 구간_개수)
	{
		println("[{:>2}] - {}", 구간, 개수);
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-06-05 오후 6:43:15 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 5일 목요일				(13주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// Associative Container
// - set<key>			: key와 value를 구분하지 않는다.
// - Map<key, value>	: <아이돌그룹, 멤버>
//-----------------------------------------------------------

#include <iostream>
#include <map>
#include <random>
#include <array>
#include <print>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] uniform 분포는 uniform 한가?
// [문제] normal 분포는 normal한가?

default_random_engine dre;	// mt19937 엔진
uniform_int_distribution uid{ 0,99'9999 };
normal_distribution nd{0.0, 0.5};


array<int, 2025'0605> a;

int main(){
	for (int& num : a)
	{
		double d = nd(dre);
		d *= 50'0000;
		d += 50'0000;

		if (0 <= d && d < 100'0000)
		{
			num = (int)d;
		}

	}
	
	map<int, size_t> 구간_개수;

	for (const int& num : a)
	{
		구간_개수[num / 5'0000]++;
	}

	for (const auto& [구간, 개수] : 구간_개수)
	{
		println("[{:>2}] - {}", 구간, 개수);
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-06-05 오후 6:43:25 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 5일 목요일				(13주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// Associative Container
// - set<key>			: key와 value를 구분하지 않는다.
// - Map<key, value>	: <아이돌그룹, 멤버>
//-----------------------------------------------------------

#include <iostream>
#include <map>
#include <random>
#include <array>
#include <print>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] uniform 분포는 uniform 한가?
// [문제] normal 분포는 normal한가?

default_random_engine dre;	// mt19937 엔진
uniform_int_distribution uid{ 0,99'9999 };
normal_distribution nd{0.0, 0.5};


array<int, 2025'0605> a;

int main(){
	for (int& num : a)
	{
		double d = nd(dre);
		d *= 20'0000;
		d += 50'0000;

		if (0 <= d && d < 100'0000)
		{
			num = (int)d;
		}

	}
	
	map<int, size_t> 구간_개수;

	for (const int& num : a)
	{
		구간_개수[num / 5'0000]++;
	}

	for (const auto& [구간, 개수] : 구간_개수)
	{
		println("[{:>2}] - {}", 구간, 개수);
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-06-05 오후 6:43:46 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 5일 목요일				(13주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// Associative Container
// - set<key>			: key와 value를 구분하지 않는다.
// - Map<key, value>	: <아이돌그룹, 멤버>
//-----------------------------------------------------------

#include <iostream>
#include <map>
#include <random>
#include <array>
#include <print>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] uniform 분포는 uniform 한가?
// [문제] normal 분포는 normal한가?

default_random_engine dre;	// mt19937 엔진
uniform_int_distribution uid{ 0,99'9999 };
normal_distribution nd{0.0, 0.01};


array<int, 2025'0605> a;

int main(){
	for (int& num : a)
	{
		double d = nd(dre);
		d *= 20'0000;
		d += 50'0000;

		if (0 <= d && d < 100'0000)
		{
			num = (int)d;
		}

	}
	
	map<int, size_t> 구간_개수;

	for (const int& num : a)
	{
		구간_개수[num / 5'0000]++;
	}

	for (const auto& [구간, 개수] : 구간_개수)
	{
		println("[{:>2}] - {}", 구간, 개수);
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-06-05 오후 6:43:57 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 5일 목요일				(13주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// Associative Container
// - set<key>			: key와 value를 구분하지 않는다.
// - Map<key, value>	: <아이돌그룹, 멤버>
//-----------------------------------------------------------

#include <iostream>
#include <map>
#include <random>
#include <array>
#include <print>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] uniform 분포는 uniform 한가?
// [문제] normal 분포는 normal한가?

default_random_engine dre;	// mt19937 엔진
uniform_int_distribution uid{ 0,99'9999 };
normal_distribution nd{0.0, 0.1};


array<int, 2025'0605> a;

int main(){
	for (int& num : a)
	{
		double d = nd(dre);
		d *= 20'0000;
		d += 50'0000;

		if (0 <= d && d < 100'0000)
		{
			num = (int)d;
		}

	}
	
	map<int, size_t> 구간_개수;

	for (const int& num : a)
	{
		구간_개수[num / 5'0000]++;
	}

	for (const auto& [구간, 개수] : 구간_개수)
	{
		println("[{:>2}] - {}", 구간, 개수);
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-06-05 오후 6:44:15 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 5일 목요일				(13주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// Associative Container
// - set<key>			: key와 value를 구분하지 않는다.
// - Map<key, value>	: <아이돌그룹, 멤버>
//-----------------------------------------------------------

#include <iostream>
#include <map>
#include <random>
#include <array>
#include <print>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] uniform 분포는 uniform 한가?
// [문제] normal 분포는 normal한가?

default_random_engine dre;	// mt19937 엔진
uniform_int_distribution uid{ 0,99'9999 };
normal_distribution nd{0.0, 0.025};


array<int, 2025'0605> a;

int main(){
	for (int& num : a)
	{
		double d = nd(dre);
		d *= 20'0000;
		d += 50'0000;

		if (0 <= d && d < 100'0000)
		{
			num = (int)d;
		}

	}
	
	map<int, size_t> 구간_개수;

	for (const int& num : a)
	{
		구간_개수[num / 5'0000]++;
	}

	for (const auto& [구간, 개수] : 구간_개수)
	{
		println("[{:>2}] - {}", 구간, 개수);
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-06-05 오후 6:44:26 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 5일 목요일				(13주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// Associative Container
// - set<key>			: key와 value를 구분하지 않는다.
// - Map<key, value>	: <아이돌그룹, 멤버>
//-----------------------------------------------------------

#include <iostream>
#include <map>
#include <random>
#include <array>
#include <print>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// [문제] uniform 분포는 uniform 한가?
// [문제] normal 분포는 normal한가?

default_random_engine dre;	// mt19937 엔진
uniform_int_distribution uid{ 0,99'9999 };
normal_distribution nd{0.0, 0.25};


array<int, 2025'0605> a;

int main(){
	for (int& num : a)
	{
		double d = nd(dre);
		d *= 20'0000;
		d += 50'0000;

		if (0 <= d && d < 100'0000)
		{
			num = (int)d;
		}

	}
	
	map<int, size_t> 구간_개수;

	for (const int& num : a)
	{
		구간_개수[num / 5'0000]++;
	}

	for (const auto& [구간, 개수] : 구간_개수)
	{
		println("[{:>2}] - {}", 구간, 개수);
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-06-05 오후 7:01:35 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 5일 목요일				(13주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// Unordered Associative Container - hash 기반
//-----------------------------------------------------------

#include <iostream>
#include "string"
#include <unordered_set>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// trade - off				찾기 성능(time)		공간 성능(memory)
// Sequence					- O(N)				- N
// Associative				- O(log N)			- N + pointer
// Unordered Associative	- O(1)				- N + table + pointer

int main(){
	unordered_set<string> us{ "1","22","333","4444","55555" };

	for (const string& s : us)
	{
		cout << s << endl;
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-06-09 오후 5:25:43 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 9일 월요일				(14주 1일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// Unordered Associative Container - hash 기반
//-----------------------------------------------------------

#include <iostream>
#include "string"
#include <unordered_set>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// trade - off				찾기 성능(time)		공간 성능(memory)
// Sequence					- O(N)				- N
// Associative				- O(log N)			- N + pointer
// Unordered Associative	- O(1)				- N + table + pointer

int main(){
	unordered_set<string> us{ "1","22","333","4444","55555" };

	for (const string& s : us)
	{
		cout << s << endl;
	}

	cout << std::hash<string>{}("55555") << endl;
	cout << std::hash<string>{}("4444") << endl;

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-06-09 오후 5:45:11 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 9일 월요일				(14주 1일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// Unordered Associative Container - hash 기반
//-----------------------------------------------------------

#include <iostream>
#include "string"
#include <unordered_set>
#include <random>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

default_random_engine dre;
uniform_int_distribution uid{ 0,99'9999 };

// constant consistency
template<>
struct hash<STRING> // 특수화
{
	size_t operator()(const STRING& t) const
	{
		return hash<std::string>{}(std::string(t.begin(),t.end())); // STRING을 std::string으로 바꾸면 가능하며 이상적이다.
	}
};

int main(){
	unordered_set<STRING,hash<STRING>> us{ "1","22","333","4444" };

	us.insert("55555");

	for (const STRING& s : us)
	{
		cout << s << endl;
	}

	save("메인.cpp");
}

// hash값으로 uid(dre) 넘겼는데 항상 1 22 333 4444 55555 로 나옴 ???

==========================================
저장한 시간: 2025-06-09 오후 5:55:47 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 9일 월요일				(14주 1일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// Unordered Associative Container - hash 기반
//-----------------------------------------------------------

#include <iostream>
#include <unordered_set>
#include <print>
#include "string"
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// constant consistency
template<>
struct hash<STRING> // 특수화
{
	size_t operator()(const STRING& t) const
	{
		return hash<std::string>{}(std::string(t.begin(),t.end())); // STRING을 std::string으로 바꾸면 가능하며 이상적이다.
	}
};

int main(){
	save("메인.cpp");

	unordered_set<STRING,hash<STRING>> us{ "1","22","333","4444" };
	// unordered set의 메모리 구조를 그대로 화면에 출력한다.
	// VS는 vector[n] + list * [n]

	string input;
	while (true)
	{
		for (size_t bc = 0; bc < us.bucket_count(); ++bc)
		{
			print("[{:3}]", bc);

			for (auto i = us.begin(bc); i != us.end(bc); ++i)
			{
				print(" <-> {}", std::string(i->begin(),i->end()));
			}
			cout << endl;
		}
		cout << endl << "추가할 STRING을 입력 - ";
		STRING s;
		cin >> s;
		us.insert(s);
	}

}

// hash값으로 uid(dre) 넘겼는데 항상 1 22 333 4444 55555 로 나옴 ???

==========================================
저장한 시간: 2025-06-09 오후 5:56:14 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 9일 월요일				(14주 1일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// Unordered Associative Container - hash 기반
//-----------------------------------------------------------

#include <iostream>
#include <unordered_set>
#include <print>
#include "string"
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// constant consistency
template<>
struct hash<STRING> // 특수화
{
	size_t operator()(const STRING& t) const
	{
		return hash<std::string>{}(std::string(t.begin(),t.end())); // STRING을 std::string으로 바꾸면 가능하며 이상적이다.
	}
};

int main(){
	save("메인.cpp");

	unordered_set<STRING,hash<STRING>> us{ "1","22","333","4444" };
	// unordered set의 메모리 구조를 그대로 화면에 출력한다.
	// VS는 vector[n] + list * [n]

	string input;
	while (true)
	{
		for (size_t bc = 0; bc < us.bucket_count(); ++bc)
		{
			print("[{:3}]", bc);

			for (auto i = us.begin(bc); i != us.end(bc); ++i)
			{
				print(" <-> {}", std::string(i->begin(),i->end()));
			}
			cout << endl;
		}
		cout << endl << "추가할 STRING을 입력 - ";
		STRING s;
		cin >> s;
		us.insert(s);
	}

}

// hash값으로 uid(dre) 넘겼는데 항상 1 22 333 4444 55555 로 나옴 ???

==========================================
저장한 시간: 2025-06-09 오후 5:56:34 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 9일 월요일				(14주 1일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// Unordered Associative Container - hash 기반
//-----------------------------------------------------------

#include <iostream>
#include <unordered_set>
#include <print>
#include "string"
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// constant consistency
template<>
struct hash<STRING> // 특수화
{
	size_t operator()(const STRING& t) const
	{
		return hash<std::string>{}(std::string(t.begin(),t.end())); // STRING을 std::string으로 바꾸면 가능하며 이상적이다.
	}
};

int main(){
	save("메인.cpp");

	unordered_set<STRING,hash<STRING>> us{ "1","22","333","4444" };
	// unordered set의 메모리 구조를 그대로 화면에 출력한다.
	// VS는 vector[n] + list * [n]

	string input;
	while (true)
	{
		for (size_t bc = 0; bc < us.bucket_count(); ++bc)
		{
			print("[{:3}]", bc);

			for (auto i = us.begin(bc); i != us.end(bc); ++i)
			{
				print(" <-> {}", std::string(i->begin(),i->end()));
			}
			cout << endl;
		}
		cout << endl << "추가할 STRING을 입력 - ";
		STRING s;
		cin >> s;
		us.insert(s);
	}

}

// hash값으로 uid(dre) 넘겼는데 항상 1 22 333 4444 55555 로 나옴 ???

==========================================
저장한 시간: 2025-06-09 오후 6:11:12 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 9일 월요일				(14주 1일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// 컨테이너의 찾기 실력을 알아본다.
// 1. vector			-
// 2. set				-
// 3. unirdered set		-
//-----------------------------------------------------------

#include <iostream>
#include <array>
#include <vector>
#include <set>
#include <unordered_set>
#include <random>
#include <chrono>
#include <algorithm>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// int 천만개를 준비한 후 int 만개가 천만개 중에 있는 지 찾아본다.

default_random_engine dre;
uniform_int_distribution uid{ 0,1000'0000 };

const int NUM{ 1000'0000 };
const int FNUM{ 1'0000 };

array<int, NUM> a;
array<int, FNUM> Fa;

int main(){
	// 데이터 준비
	for (int& num : a) num = uid(dre);
	for (int& num : Fa) num = uid(dre);

	{	//vector의 찾기 실력
		vector<int> v(a.begin(), a.end());
		cout << "vector " << v.size() << "개의 원소 중에서 " << Fa.size() << "개의 원소 찾기" << endl;

		size_t cnt{};

		// 시간
		auto start = std::chrono::high_resolution_clock::now();
		for (int num : Fa)
		{
			auto p = find(v.begin(), v.end(), num);

			if (p != v.end())
				++cnt;
		}
		// 시간
		auto end = std::chrono::high_resolution_clock::now();
		cout << "찾은 수 - " << cnt << endl;
		cout << "걸린 시간 - " << end - start << endl;
	}
	save("메인.cpp");
}

==========================================
저장한 시간: 2025-06-09 오후 6:13:45 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 9일 월요일				(14주 1일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// 컨테이너의 찾기 실력을 알아본다.
// 1. vector			-
// 2. set				-
// 3. unirdered set		-
//-----------------------------------------------------------

#include <iostream>
#include <array>
#include <vector>
#include <set>
#include <unordered_set>
#include <random>
#include <chrono>
#include <algorithm>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// int 천만개를 준비한 후 int 만개가 천만개 중에 있는 지 찾아본다.

default_random_engine dre;
uniform_int_distribution uid{ 0,1000'0000 };

const int NUM{ 1000'0000 };
const int FNUM{ 1'0000 };

array<int, NUM> a;
array<int, FNUM> Fa;

int main(){
	// 데이터 준비
	for (int& num : a) num = uid(dre);
	for (int& num : Fa) num = uid(dre);

	{	//vector의 찾기 실력
		vector<int> v(a.begin(), a.end());
		cout << "vector " << v.size() << "개의 원소 중에서 " << Fa.size() << "개의 원소 찾기" << endl;

		size_t cnt{};

		// 시간
		auto start = std::chrono::high_resolution_clock::now();
		for (int num : Fa)
		{
			auto p = find(v.begin(), v.end(), num);

			if (p != v.end())
				++cnt;
		}
		// 시간
		auto end = std::chrono::high_resolution_clock::now();
		cout << "찾은 수 - " << cnt << endl;
		cout << "걸린 시간 - " << chrono::duration_cast<chrono::milliseconds>(end - start) << endl;
	}
	save("메인.cpp");
}

==========================================
저장한 시간: 2025-06-09 오후 6:16:05 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 9일 월요일				(14주 1일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// 컨테이너의 찾기 실력을 알아본다.
// 1. vector			-
// 2. set				-
// 3. unordered set		-
//-----------------------------------------------------------

#include <iostream>
#include <array>
#include <vector>
#include <set>
#include <unordered_set>
#include <random>
#include <chrono>
#include <algorithm>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// int 천만개를 준비한 후 int 만개가 천만개 중에 있는 지 찾아본다.

default_random_engine dre;
uniform_int_distribution uid{ 0,1000'0000 };

const int NUM{ 1000'0000 };
const int FNUM{ 1'0000 };

array<int, NUM> a;
array<int, FNUM> Fa;

int main(){
	// 데이터 준비
	for (int& num : a) num = uid(dre);
	for (int& num : Fa) num = uid(dre);

	{	//vector의 찾기 실력
		vector<int> v(a.begin(), a.end());
		cout << "vector " << v.size() << "개의 원소 중에서 " << Fa.size() << "개의 원소 찾기" << endl;

		size_t cnt{};

		// 시간
		auto start = std::chrono::high_resolution_clock::now();
		for (int num : Fa)
		{
			auto p = find(v.begin(), v.end(), num);

			if (p != v.end())
				++cnt;
		}
		// 시간
		auto end = std::chrono::high_resolution_clock::now();
		cout << "찾은 수 - " << cnt << endl;
		cout << "걸린 시간 - " << chrono::duration_cast<chrono::milliseconds>(end - start) << endl;
	}

	{	//set의 찾기 실력
		set<int> s(a.begin(), a.end());
		cout << "vector " << s.size() << "개의 원소 중에서 " << Fa.size() << "개의 원소 찾기" << endl;

		size_t cnt{};

		// 시간
		auto start = std::chrono::high_resolution_clock::now();
		for (int num : Fa)
		{
			auto p = s.find(num);

			if (p != s.end())
				++cnt;
		}
		// 시간
		auto end = std::chrono::high_resolution_clock::now();
		cout << "찾은 수 - " << cnt << endl;
		cout << "걸린 시간 - " << chrono::duration_cast<chrono::milliseconds>(end - start) << endl;
	}

	{	//unordered set의 찾기 실력
		unordered_set<int> us(a.begin(), a.end());
		cout << "vector " << us.size() << "개의 원소 중에서 " << Fa.size() << "개의 원소 찾기" << endl;

		size_t cnt{};

		// 시간
		auto start = std::chrono::high_resolution_clock::now();
		for (int num : Fa)
		{
			auto p = us.find(num);

			if (p != us.end())
				++cnt;
		}
		// 시간
		auto end = std::chrono::high_resolution_clock::now();
		cout << "찾은 수 - " << cnt << endl;
		cout << "걸린 시간 - " << chrono::duration_cast<chrono::milliseconds>(end - start) << endl;
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-06-09 오후 6:16:52 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 9일 월요일				(14주 1일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// 컨테이너의 찾기 실력을 알아본다.
// 1. vector			-
// 2. set				-
// 3. unordered set		-
//-----------------------------------------------------------

#include <iostream>
#include <array>
#include <vector>
#include <set>
#include <unordered_set>
#include <random>
#include <chrono>
#include <algorithm>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// int 천만개를 준비한 후 int 만개가 천만개 중에 있는 지 찾아본다.

default_random_engine dre;
uniform_int_distribution uid{ 0,1000'0000 };

const int NUM{ 1000'0000 };
const int FNUM{ 1'0000 };

array<int, NUM> a;
array<int, FNUM> Fa;

int main(){
	// 데이터 준비
	for (int& num : a) num = uid(dre);
	for (int& num : Fa) num = uid(dre);

	{	//vector의 찾기 실력
		vector<int> v(a.begin(), a.end());
		cout << "vector " << v.size() << "개의 원소 중에서 " << Fa.size() << "개의 원소 찾기" << endl;

		size_t cnt{};

		// 시간
		auto start = std::chrono::high_resolution_clock::now();
		for (int num : Fa)
		{
			auto p = find(v.begin(), v.end(), num);

			if (p != v.end())
				++cnt;
		}
		// 시간
		auto end = std::chrono::high_resolution_clock::now();
		cout << "찾은 수 - " << cnt << endl;
		cout << "걸린 시간 - " << chrono::duration_cast<chrono::milliseconds>(end - start) << endl;
	}
	cout << endl;
	{	//set의 찾기 실력
		set<int> s(a.begin(), a.end());
		cout << "set " << s.size() << "개의 원소 중에서 " << Fa.size() << "개의 원소 찾기" << endl;

		size_t cnt{};

		// 시간
		auto start = std::chrono::high_resolution_clock::now();
		for (int num : Fa)
		{
			auto p = s.find(num);

			if (p != s.end())
				++cnt;
		}
		// 시간
		auto end = std::chrono::high_resolution_clock::now();
		cout << "찾은 수 - " << cnt << endl;
		cout << "걸린 시간 - " << chrono::duration_cast<chrono::milliseconds>(end - start) << endl;
	}
	cout << endl;
	{	//unordered set의 찾기 실력
		unordered_set<int> us(a.begin(), a.end());
		cout << "unordered_set " << us.size() << "개의 원소 중에서 " << Fa.size() << "개의 원소 찾기" << endl;

		size_t cnt{};

		// 시간
		auto start = std::chrono::high_resolution_clock::now();
		for (int num : Fa)
		{
			auto p = us.find(num);

			if (p != us.end())
				++cnt;
		}
		// 시간
		auto end = std::chrono::high_resolution_clock::now();
		cout << "찾은 수 - " << cnt << endl;
		cout << "걸린 시간 - " << chrono::duration_cast<chrono::milliseconds>(end - start) << endl;
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-06-09 오후 6:19:14 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 9일 월요일				(14주 1일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// 컨테이너의 찾기 실력을 알아본다.
// 1. vector			-
// 2. set				-
// 3. unordered set		-
//-----------------------------------------------------------

#include <iostream>
#include <array>
#include <vector>
#include <set>
#include <unordered_set>
#include <random>
#include <chrono>
#include <algorithm>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// int 천만개를 준비한 후 int 만개가 천만개 중에 있는 지 찾아본다.

default_random_engine dre;
uniform_int_distribution uid{ 0,1000'0000 };

const int NUM{ 1000'0000 };
const int FNUM{ 1'0000 };

array<int, NUM> a;
array<int, FNUM> Fa;

int main(){
	// 데이터 준비
	for (int& num : a) num = uid(dre);
	for (int& num : Fa) num = uid(dre);

	{	//vector의 찾기 실력
		vector<int> v(a.begin(), a.end());
		cout << "vector " << v.size() << "개의 원소 중에서 " << Fa.size() << "개의 원소 찾기" << endl;

		size_t cnt{};

		// 시간
		auto start = std::chrono::high_resolution_clock::now();
		for (int num : Fa)
		{
			auto p = find(v.begin(), v.end(), num);

			if (p != v.end())
				++cnt;
		}
		// 시간
		auto end = std::chrono::high_resolution_clock::now();
		cout << "찾은 수 - " << cnt << endl;
		cout << "걸린 시간 - " << chrono::duration_cast<chrono::milliseconds>(end - start) << endl;
	}
	cout << endl;
	{	//set의 찾기 실력
		set<int> s(a.begin(), a.end());
		cout << "set " << s.size() << "개의 원소 중에서 " << Fa.size() << "개의 원소 찾기" << endl;

		size_t cnt{};

		// 시간
		auto start = std::chrono::high_resolution_clock::now();
		for (int num : Fa)
		{
			auto p = s.find(num);

			if (p != s.end())
				++cnt;
		}
		// 시간
		auto end = std::chrono::high_resolution_clock::now();
		cout << "찾은 수 - " << cnt << endl;
		cout << "걸린 시간 - " << chrono::duration_cast<chrono::milliseconds>(end - start) << endl;
	}
	cout << endl;
	{	//multiset의 찾기 실력
		multiset<int> s(a.begin(), a.end());
		cout << "multiset " << s.size() << "개의 원소 중에서 " << Fa.size() << "개의 원소 찾기" << endl;

		size_t cnt{};

		// 시간
		auto start = std::chrono::high_resolution_clock::now();
		for (int num : Fa)
		{
			auto p = s.find(num);

			if (p != s.end())
				++cnt;
		}
		// 시간
		auto end = std::chrono::high_resolution_clock::now();
		cout << "찾은 수 - " << cnt << endl;
		cout << "걸린 시간 - " << chrono::duration_cast<chrono::milliseconds>(end - start) << endl;
	}
	cout << endl;
	{	//unordered set의 찾기 실력
		unordered_set<int> us(a.begin(), a.end());
		cout << "unordered_set " << us.size() << "개의 원소 중에서 " << Fa.size() << "개의 원소 찾기" << endl;

		size_t cnt{};

		// 시간
		auto start = std::chrono::high_resolution_clock::now();
		for (int num : Fa)
		{
			auto p = us.find(num);

			if (p != us.end())
				++cnt;
		}
		// 시간
		auto end = std::chrono::high_resolution_clock::now();
		cout << "찾은 수 - " << cnt << endl;
		cout << "걸린 시간 - " << chrono::duration_cast<chrono::milliseconds>(end - start) << endl;
	}
	cout << endl;
	{	//unordered_multiset의 찾기 실력
		unordered_multiset<int> us(a.begin(), a.end());
		cout << "unordered_multiset " << us.size() << "개의 원소 중에서 " << Fa.size() << "개의 원소 찾기" << endl;

		size_t cnt{};

		// 시간
		auto start = std::chrono::high_resolution_clock::now();
		for (int num : Fa)
		{
			auto p = us.find(num);

			if (p != us.end())
				++cnt;
		}
		// 시간
		auto end = std::chrono::high_resolution_clock::now();
		cout << "찾은 수 - " << cnt << endl;
		cout << "걸린 시간 - " << chrono::duration_cast<chrono::milliseconds>(end - start) << endl;
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-06-09 오후 6:22:08 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 9일 월요일				(14주 1일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// 컨테이너의 찾기 실력을 알아본다.
// 1. vector			-
// 2. set				-
// 3. unordered set		-
//-----------------------------------------------------------

#include <iostream>
#include <array>
#include <vector>
#include <set>
#include <unordered_set>
#include <random>
#include <chrono>
#include <algorithm>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// int 천만개를 준비한 후 int 만개가 천만개 중에 있는 지 찾아본다.

default_random_engine dre;
uniform_int_distribution uid{ 0,1000'0000 };

const int NUM{ 1000'0000 };
const int FNUM{ 1'0000 };

array<int, NUM> a;
array<int, FNUM> Fa;

int main(){
	// 데이터 준비
	for (int& num : a) num = uid(dre);
	for (int& num : Fa) num = uid(dre);

	cout << "Initing..." << endl;
	vector<int> v(a.begin(), a.end());
	set<int> s(a.begin(), a.end());
	multiset<int> ms(a.begin(), a.end());
	unordered_set<int> us(a.begin(), a.end());
	unordered_multiset<int> ums(a.begin(), a.end());

	cout << "Start Program" << endl << endl << endl;


	{	//vector의 찾기 실력
		cout << "vector " << v.size() << "개의 원소 중에서 " << Fa.size() << "개의 원소 찾기" << endl;

		size_t cnt{};

		// 시간
		auto start = std::chrono::high_resolution_clock::now();
		for (int num : Fa)
		{
			auto p = find(v.begin(), v.end(), num);

			if (p != v.end())
				++cnt;
		}
		// 시간
		auto end = std::chrono::high_resolution_clock::now();
		cout << "찾은 수 - " << cnt << endl;
		cout << "걸린 시간 - " << chrono::duration_cast<chrono::milliseconds>(end - start) << endl;
	}
	cout << endl;
	{	//set의 찾기 실력
		cout << "set " << s.size() << "개의 원소 중에서 " << Fa.size() << "개의 원소 찾기" << endl;

		size_t cnt{};

		// 시간
		auto start = std::chrono::high_resolution_clock::now();
		for (int num : Fa)
		{
			auto p = s.find(num);

			if (p != s.end())
				++cnt;
		}
		// 시간
		auto end = std::chrono::high_resolution_clock::now();
		cout << "찾은 수 - " << cnt << endl;
		cout << "걸린 시간 - " << chrono::duration_cast<chrono::milliseconds>(end - start) << endl;
	}
	cout << endl;
	{	//multiset의 찾기 실력
		cout << "multiset " << s.size() << "개의 원소 중에서 " << Fa.size() << "개의 원소 찾기" << endl;

		size_t cnt{};

		// 시간
		auto start = std::chrono::high_resolution_clock::now();
		for (int num : Fa)
		{
			auto p = s.find(num);

			if (p != s.end())
				++cnt;
		}
		// 시간
		auto end = std::chrono::high_resolution_clock::now();
		cout << "찾은 수 - " << cnt << endl;
		cout << "걸린 시간 - " << chrono::duration_cast<chrono::milliseconds>(end - start) << endl;
	}
	cout << endl;
	{	//unordered set의 찾기 실력
		cout << "unordered_set " << us.size() << "개의 원소 중에서 " << Fa.size() << "개의 원소 찾기" << endl;

		size_t cnt{};

		// 시간
		auto start = std::chrono::high_resolution_clock::now();
		for (int num : Fa)
		{
			auto p = us.find(num);

			if (p != us.end())
				++cnt;
		}
		// 시간
		auto end = std::chrono::high_resolution_clock::now();
		cout << "찾은 수 - " << cnt << endl;
		cout << "걸린 시간 - " << chrono::duration_cast<chrono::milliseconds>(end - start) << endl;
	}
	cout << endl;
	{	//unordered_multiset의 찾기 실력
		cout << "unordered_multiset " << us.size() << "개의 원소 중에서 " << Fa.size() << "개의 원소 찾기" << endl;

		size_t cnt{};

		// 시간
		auto start = std::chrono::high_resolution_clock::now();
		for (int num : Fa)
		{
			auto p = us.find(num);

			if (p != us.end())
				++cnt;
		}
		// 시간
		auto end = std::chrono::high_resolution_clock::now();
		cout << "찾은 수 - " << cnt << endl;
		cout << "걸린 시간 - " << chrono::duration_cast<chrono::milliseconds>(end - start) << endl;
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-06-09 오후 6:51:58 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 9일 월요일				(14주 1일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// 컨테이너의 찾기 실력을 알아본다.
// 1. vector			- X(찾기에 적합하지 않음)
// 1.5 sorted vector	- 3
// 2. set				- 2
// 3. unordered set		- 1
//-----------------------------------------------------------

#include <iostream>
#include <array>
#include <vector>
#include <set>
#include <unordered_set>
#include <random>
#include <chrono>
#include <algorithm>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

// int 천만개를 준비한 후 int 만개가 천만개 중에 있는 지 찾아본다.

default_random_engine dre;
uniform_int_distribution uid{ 0,1000'0000 };

const int NUM{ 1000'0000 };
const int FNUM{ 1'0000 };

array<int, NUM> a;
array<int, FNUM> Fa;

int main(){
	save("메인.cpp");

	// 데이터 준비
	for (int& num : a) num = uid(dre);
	for (int& num : Fa) num = uid(dre);

	cout << "Initing..." << endl;
	vector<int> v(a.begin(), a.end());
	set<int> s(a.begin(), a.end());
	multiset<int> ms(a.begin(), a.end());
	unordered_set<int> us(a.begin(), a.end());
	unordered_multiset<int> ums(a.begin(), a.end());
	vector<int> sv(a.begin(), a.end());
	sort(sv.begin(), sv.end());

	cout << "Start Program" << endl << endl << endl;
	string input{};
	while (true)
	{
		{	//vector의 찾기 실력
			cout << "vector " << v.size() << "개의 원소 중에서 " << Fa.size() << "개의 원소 찾기" << endl;

			size_t cnt{};

			// 시간
			auto start = std::chrono::high_resolution_clock::now();
			for (int num : Fa)
			{
				auto p = find(v.begin(), v.end(), num);

				if (p != v.end())
					++cnt;
			}
			// 시간
			auto end = std::chrono::high_resolution_clock::now();
			cout << "찾은 수 - " << cnt << endl;
			cout << "걸린 시간 - " << chrono::duration_cast<chrono::nanoseconds>(end - start) << endl;
		}
		cout << endl;
		{	//set의 찾기 실력
			cout << "set " << s.size() << "개의 원소 중에서 " << Fa.size() << "개의 원소 찾기" << endl;

			size_t cnt{};

			// 시간
			auto start = std::chrono::high_resolution_clock::now();
			for (int num : Fa)
			{
				auto p = s.find(num);

				if (p != s.end())
					++cnt;
			}
			// 시간
			auto end = std::chrono::high_resolution_clock::now();
			cout << "찾은 수 - " << cnt << endl;
			cout << "걸린 시간 - " << chrono::duration_cast<chrono::nanoseconds>(end - start) << endl;
		}
		cout << endl;
		{	//multiset의 찾기 실력
			cout << "multiset " << ms.size() << "개의 원소 중에서 " << Fa.size() << "개의 원소 찾기" << endl;

			size_t cnt{};

			// 시간
			auto start = std::chrono::high_resolution_clock::now();
			for (int num : Fa)
			{
				auto p = ms.find(num);

				if (p != ms.end())
					++cnt;
			}
			// 시간
			auto end = std::chrono::high_resolution_clock::now();
			cout << "찾은 수 - " << cnt << endl;
			cout << "걸린 시간 - " << chrono::duration_cast<chrono::nanoseconds>(end - start) << endl;
		}
		cout << endl;
		{	//unordered set의 찾기 실력
			cout << "unordered_set " << us.size() << "개의 원소 중에서 " << Fa.size() << "개의 원소 찾기" << endl;

			size_t cnt{};

			// 시간
			auto start = std::chrono::high_resolution_clock::now();
			for (int num : Fa)
			{
				auto p = us.find(num);

				if (p != us.end())
					++cnt;
			}
			// 시간
			auto end = std::chrono::high_resolution_clock::now();
			cout << "찾은 수 - " << cnt << endl;
			cout << "걸린 시간 - " << chrono::duration_cast<chrono::nanoseconds>(end - start) << endl;
		}
		cout << endl;
		{	//unordered_multiset의 찾기 실력
			cout << "unordered_multiset " << ums.size() << "개의 원소 중에서 " << Fa.size() << "개의 원소 찾기" << endl;

			size_t cnt{};

			// 시간
			auto start = std::chrono::high_resolution_clock::now();
			for (int num : Fa)
			{
				auto p = ums.find(num);

				if (p != ums.end())
					++cnt;
			}
			// 시간
			auto end = std::chrono::high_resolution_clock::now();
			cout << "찾은 수 - " << cnt << endl;
			cout << "걸린 시간 - " << chrono::duration_cast<chrono::nanoseconds>(end - start) << endl;
		} 
		cout << endl;
		{	//정렬한 vector의 찾기 실력
			cout << "sorted vector " << sv.size() << "개의 원소 중에서 " << Fa.size() << "개의 원소 찾기" << endl;

			size_t cnt{};

			// 시간
			auto start = std::chrono::high_resolution_clock::now();
			for (int num : Fa)
			{
				if ( binary_search(sv.begin(),sv.end(),num) )
					++cnt;
			}
			// 시간
			auto end = std::chrono::high_resolution_clock::now();
			cout << "찾은 수 - " << cnt << endl;
			cout << "걸린 시간 - " << chrono::duration_cast<chrono::nanoseconds>(end - start) << endl;
		}
		cin >> input;
		if (input == "0") break;
	}
}

==========================================
저장한 시간: 2025-06-12 오후 5:48:49 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 12일 목요일				(14주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// Non-modifying sequence operations
// Modifying sequence operations
// Sorting and related operations
//-----------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <string>
#include <print>
#include <chrono>
#include <thread>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){
	save("메인.cpp");

	string s{ "C++ Standard Template Library - 2025. 6. 12." };

	for (int i = 0; i < 12; ++i) cout << "\n";
	while (true)
	{
		print("{:^80}", s);
		this_thread::sleep_for(100ms);// 100ms 정지
		std::rotate(s.begin(), s.begin() + 1, s.end());
		cout << '\r';
	}

}

==========================================
저장한 시간: 2025-06-12 오후 5:49:55 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 12일 목요일				(14주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// Non-modifying sequence operations
// Modifying sequence operations
// Sorting and related operations
//-----------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <string>
#include <print>
#include <chrono>
#include <thread>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){
	save("메인.cpp");

	string s{ "C++ Standard Template Library - 2025. 6. 12." };

	for (int i = 0; i < 12; ++i) cout << "\n";
	while (true)
	{
		print("{:^80}", s);
		this_thread::sleep_for(100ms);// 100ms 정지
		std::rotate(s.begin(), s.end()-1, s.end());
		cout << '\r';
	}

}

==========================================
저장한 시간: 2025-06-12 오후 6:25:36 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 12일 목요일				(14주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// STL sort 관련 알고리즘 - 복잡도 순서대로
// 1. partition
// 2. nth_element
// 3. partial_sort
// 4. sort
// 5. stable_sort
//-----------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include <print>
#include <random>
#include <numeric>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

default_random_engine dre{ random_device{}() };

int main(){
	save("메인.cpp");

	vector<int> v(100);
	iota(v.begin(), v.end(), 1);

	{
		shuffle(v.begin(), v.end(), dre);
		cout << "sort 하기 전" << endl;
		for (int num : v)
			print("{:8}", num);
		cout << endl;

		sort(v.begin(), v.end());

		cout << "sort 후" << endl;
		for (auto i = v.begin(); i < v.end(); ++i)
			print("{:8}", *i);

		cout << endl;
		cout << endl;
	}

	
	{
		shuffle(v.begin(), v.end(), dre);
		cout << "partial_sort 하기 전" << endl;
		for (int num : v)
			print("{:8}", num);
		cout << endl;

		cout << "40등까지와 나머지로 분리" << endl;
		partial_sort(v.begin(), v.begin() + 40, v.end());

		cout << "앞에서부터 40개" << endl;
		for (auto i = v.begin(); i < v.begin() + 40; ++i)
			print("{:8}", *i);

		cout << endl;

		cout << "나머지" << endl;
		for (auto i = v.begin() + 40; i < v.end(); ++i)
			print("{:8}", *i);

		cout << endl;
		cout << endl;
	}

	{
		shuffle(v.begin(), v.end(), dre);
		cout << "nth_element 하기 전" << endl;
		for (int num : v)
			print("{:8}", num);
		cout << endl;

		cout << "앞에서부터 40개와 나머지로 분리" << endl;
		nth_element(v.begin(), v.begin() + 40, v.end());

		cout << "앞에서부터 40개" << endl;
		for (auto i = v.begin(); i < v.begin() + 40; ++i)
			print("{:8}", *i);

		cout << endl;

		cout << "나머지" << endl;
		for (auto i = v.begin() + 40; i < v.end(); ++i)
			print("{:8}", *i);

		cout << endl;
		cout << endl;
	}

	{
		shuffle(v.begin(), v.end(), dre);
		cout << "partition 하기 전" << endl;
		for (int num : v)
			print("{:8}", num);
		cout << endl;

		cout << "홀수와 짝수로 분리" << endl;
		auto p = partition(v.begin(), v.end(), [](int num)
			{
				return num & 1;
			});

		cout << "홀수" << endl;
		for (auto i = v.begin(); i < p; ++i)
			print("{:8}", *i);

		cout << endl;

		cout << "짝수" << endl;
		for (auto i = p; i < v.end(); ++i)
			print("{:8}", *i);

		cout << endl;
		cout << endl;
	}
	
}

==========================================
저장한 시간: 2025-06-12 오후 6:44:01 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 12일 목요일				(14주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// STL sort 관련 알고리즘 - 복잡도 순서대로
// 1. partition
// 2. nth_element
// 3. partial_sort
// 4. sort
// 5. stable_sort
//-----------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include <print>
#include <random>
#include <numeric>
#include <ranges>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

default_random_engine dre{ random_device{}() };
uniform_int_distribution<int> uidChar{ 'A','Z' };
uniform_int_distribution uid{ 1,100 };

struct Dog
{
	char c { static_cast<char> (uidChar(dre)) };
	int n { uid(dre) };
	
	friend ostream& operator<<(ostream& os, const Dog& dog)
	{
		print(os, "[{}] - {:3}", dog.c, dog.n);
		return os;
	}


};

int main(){
	vector<Dog> dogs(100);

	//글자기준 정렬
	//sort(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b)
	//	{
	//		return a.c < b.c;
	//	});

	ranges::sort(dogs, less<char>{}, &Dog::c);

	for (const Dog& dog : dogs)
	{
		cout << dog << endl;
	}

	

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-06-12 오후 6:52:46 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 12일 목요일				(14주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// STL sort 관련 알고리즘 - 복잡도 순서대로
// 1. partition
// 2. nth_element
// 3. partial_sort
// 4. sort
// 5. stable_sort
//-----------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include <print>
#include <random>
#include <numeric>
#include <ranges>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

default_random_engine dre{ random_device{}() };
uniform_int_distribution<int> uidChar{ 'A','Z' };
uniform_int_distribution uid{ 1,50 };

struct Dog
{
	char c { static_cast<char> (uidChar(dre)) };
	int n { uid(dre) };
	
	friend ostream& operator<<(ostream& os, const Dog& dog)
	{
		print(os, "[{}] - {:3}", dog.c, dog.n);
		return os;
	}


};

int main(){
	vector<Dog> dogs(100);

	//글자기준 정렬
	//sort(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b)
	//	{
	//		return a.c < b.c;
	//	});

	ranges::sort(dogs, less<char>{}, &Dog::c);

	for (const Dog& dog : dogs)
	{
		cout << dog << endl;
	}

	cout << "상대적인 순서를 유지하며 dogs를 n기준으로 다시 정렬한다." << endl;

	ranges::stable_sort(dogs, {}, &Dog::n);

	for (const Dog& dog : dogs)
	{
		cout << dog << endl;
	}

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-06-12 오후 7:05:31 목요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 12일 목요일				(14주 2일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// distance 구현 - tag dispatch, if constexpr, concept, SFINAE
//-----------------------------------------------------------

#include <iostream>
#include <vector>
#include <list>
#include <algorithm>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

template<class Iter>
iterator_traits<Iter>::difference_type my_distance(Iter b, Iter e)
{
	typename iterator_traits<Iter>::difference_type d{ 0 };
	while (b not_eq e)
	{
		++b;
		++d;
	}
	return d;
}

int main(){
	vector<int> v{ 1,2,3,4,5 };
	list<int> c{ 1,2,3,4,5 };

	cout << my_distance(v.begin(), v.end()) << endl;
	cout << my_distance(c.begin(), c.end()) << endl;

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-06-16 오후 5:38:48 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 16일 월요일				(15주 1일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// distance 구현 - tag dispatch, if constexpr, concept, SFINAE
// tag dispatch - vector_distance / list_distance 등 따로 구현하여 호출
// if constexpr - 조건에 부합하지 않으면 컴파일 X (템플릿 코드 생성때 생성하지 않음)
//-----------------------------------------------------------

#include <iostream>
#include <vector>
#include <list>
#include <algorithm>
#include <concepts>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

template<class Iter>
iterator_traits<Iter>::difference_type my_distance(Iter b, Iter e)
{
	// if 반복자가 핸덤억세스라면
	// C++20의 concepts를 사용하면 쉽게 반복자의 타입을 알 수 있다.
	if constexpr (random_access_iterator<Iter>)
	{
		return e - b;
	}
	else
	{
		typename iterator_traits<Iter>::difference_type d{ 0 };
		while (b not_eq e)
		{
			++b;
			++d;
		}
		return d;
	}

}

int main(){
	vector<int> v{ 1,2,3,4,5 };
	list<int> c{ 1,2,3,4,5 };

	cout << my_distance(v.end(), v.begin()) << endl;
	cout << my_distance(c.end(), c.begin()) << endl;

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-06-16 오후 6:04:03 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 16일 월요일				(15주 1일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// concepts - compile-time에 template 함수에 전달된 인자(타입, non-type)가 
// concept에 맞는지 안 맞는지 판단하기 위한 C++ 언어의 문법
//-----------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

template<class T>
concept Addable = integral<T> or floating_point<T> or is_convertible_v<T, std::string_view>;

template<Addable T>
T add(T a, T b)
{
	return a + b;
}


int main(){
	//[문제] 템플릿 add로 해결하자
	cout << add(1, 2) << endl;
	cout << add(1.2, 3.4) << endl;
	cout << add("2025"s, " 6 16"s) << endl;

	//cout << add(STRING{ "2025" }, STRING{ " 6 16" }) << endl;

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-06-16 오후 6:14:11 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 16일 월요일				(15주 1일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// concepts - compile-time에 template 함수에 전달된 인자(타입, non-type)가 
// concept에 맞는지 안 맞는지 판단하기 위한 C++ 언어의 문법
//-----------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <vector>
#include <list>
#include <ranges>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){
	vector<int> v{ 3,1,5,2,4 };
	ranges::sort(v.begin(), v.end());

	list<int> c{ 3,1,5,2,4 };
	//ranges::sort(c.begin(), c.end()); X
	c.sort();

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-06-16 오후 6:28:24 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 16일 월요일				(15주 1일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// concepts - compile-time에 template 함수에 전달된 인자(타입, non-type)가 
// concept에 맞는지 안 맞는지 판단하기 위한 C++ 언어의 문법
//-----------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <vector>
#include <list>
#include <ranges>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){
	// 지연평가(lazy-evaluation)
	for ( int num : views::iota(1) 
				  | views::take(1000) 
				  | views::filter([](int num) { return num & 1; }) 
				  | views::reverse)
		cout << num << " ";
	save("메인.cpp");
}

==========================================
저장한 시간: 2025-06-16 오후 6:36:10 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 16일 월요일				(15주 1일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// 한 학기 끝
//-----------------------------------------------------------

#include <iostream>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){

	save("메인.cpp");
}

==========================================
저장한 시간: 2025-06-16 오후 7:13:23 월요일
==========================================

//-----------------------------------------------------------
// 2025.1 학기		 STL 6월 16일 월요일				(15주 1일)
// 6/19 목요일 15주 2일 - 기말시험
//-----------------------------------------------------------
// 한 학기 끝
//-----------------------------------------------------------

#include <iostream>
#include "save.h"
#include "STRING.h"

using namespace std;

extern bool 관찰;

int main(){
	// special functions 
	// default ctor, dtor,
	// copy ctor, copy assignment op,
	// move ctor, move assignment op
	// 
	// RAII - 객체의 수명과 메모리의 수명을 일치시키는 기법
	// instancing - 객체를 실제로 생성하여 메모리에 저장하는 것
	// STACK, DATA, free store, CODE - 데이터가 저장되는 곳의 종류
	// 
	// Containers
	// 1. sequence				( O(N) )		- array<T,N>, vector<T>, deque<T>, list<T>, forward_list<T>
	// 2. associative			( O(log N) )	- set<T>, multiset<T>, map<k,v>, multimap<k,v>
	// 3. unordered associative ( O(1) )		- unordered_set<T>, unordered_map<k,v>
	// 
	// Iterators
	// - Category (Hierarchy) 
	//		input_iterator_tag
	//		output_iterator_tag
	//		forward_iterator_tag
	//		bidirectional_iterator_tag
	//		random_access_iterator_tag
	//		contiguous_iterator_tag
	// * 역참조 연산자(dereference), ++, == (<=>) - 등등 지원해야 Iterator로 수행 가능
	// 
	// Algorithms
	// 1. Non-modifying sequence
	// 2. Modifying sequence
	// 3. Sorting and related
	// 
	// 반복자 종류에 따른 구현 -	function dispatch (tag dispatch)
	//							C++20 concept -> if constexpr (compile-time에 결정)
	// 
	// concept + ranges ->	ranges::algorithm (constrained_algorithm)
	//						views와 결합 -> functional programing language
	// 
	
	save("메인.cpp");
}

==========================================
저장한 시간: 2025-06-16 오후 7:14:51 월요일
==========================================

//-------------------------------------------------------------------------------------------------
// STRING.cpp - STL의 동작을 이해하기 위한 class / std::string과 유사하게 작성
//
// 2025. 4. 10 - 시작
// 2025. 4. 10 - 복사생성/복사할당연산자, 스페셜 함수의 동작 관찰
// 2025. 4. 14 - 선택적 관찰하도록 전역변수를 사용, 이동의미론(move semantics) 구현
// 2025. 5. 1 - operator==
// 2025. 5. 15 - std::string과 같이 사전식 정렬하도록 수정
// 2025. 5. 15 - begin(), end()
// 2025. 5. 19 - rbegin(), rend()
//-------------------------------------------------------------------------------------------------
#include <memory>
#include <print>
#include <algorithm>
#include "STRING.h"

size_t STRING::gid{ 0 };		// 2025. 4. 10 고유번호 생성
bool 관찰{ false };

STRING::STRING()
	: id{ ++gid }
{
	if (관찰)
	{
		std::println("[{:6}] {:<16} 자원수:{:4}, 주소:{:16} 자원의주소:{:16}",
			id, "디폴트생성", num, (void*)this, (void*)p.get());
	}
}

STRING::~STRING()
{
	if (관찰)
	{
		std::println("[{:6}] {:<16} 자원수:{:4}, 주소:{:16} 자원의주소:{:16}",
			id, "소멸자", num, (void*)this, (void*)p.get());
	}
}

STRING::STRING(const char* str) 
	: num{ strlen(str) }, id{ ++gid }
{
	p.release();
	p = std::make_unique<char[]>(num);
	memcpy(p.get(), str, num);

	if (관찰)
	{
		std::println("[{:6}] {:<16} 자원수:{:4}, 주소:{:16} 자원의주소:{:16}",
			id, "생성자(char*)", num, (void*)this, (void*)p.get());
	}
};

// 복사생성자와 복사할당연산자 2025. 4. 10
STRING::STRING(const STRING& other)	// 복사 생성은 할당을 이용해서 코딩하라
	:num{ other.num }, id{ ++gid }
{
	p = std::make_unique<char[]>(num);
	memcpy(p.get(), other.p.get(), num);

	if (관찰)
	{
		std::println("[{:6}] {:<16} 자원수:{:4}, 주소:{:16} 자원의주소:{:16}",
			id, "복사생성자", num, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(const STRING& other)
{
	if (this == &other) return *this; // [int* p = &a] => address of /// [int& r = a] => reference

	num = other.num;

	p.release();
	p = std::make_unique<char[]>(num);
	memcpy(p.get(), other.p.get(), num);

	if (관찰)
	{
		std::println("[{:6}] {:<16} 자원수:{:4}, 주소:{:16} 자원의주소:{:16}",
			id, "copy operator=", num, (void*)this, (void*)p.get());
	}

	return *this;
}

STRING::STRING(STRING&& other)
	: num{ other.num }, id{ ++gid }
{
	p.reset(other.p.release());

	//other.num = 0;

	if (관찰)
	{
		std::println("[{:6}] {:<16} 자원수:{:4}, 주소:{:16} 자원의주소:{:16}",
			id, "이동생성자", num, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(STRING&& other)
{
	if (this == &other)
		return *this;

	num = other.num;
	p.release();
	p.reset(other.p.release());

	//other.num = 0;

	if (관찰)
	{
		std::println("[{:6}] {:<16} 자원수:{:4}, 주소:{:16} 자원의주소:{:16}",
			id, "move operator=", num, (void*)this, (void*)p.get());
	}

	return *this;
}

// 기본정렬을 위한 < 2025. 4. 14
// 사전식정렬하도록 수정 - 2025. 5. 15
bool STRING::operator<(const STRING& rhs) const
{
	return std::lexicographical_compare(p.get(), p.get() + num, &rhs.p[0], &rhs.p[rhs.num]);
}

// 같은 객체인지 비교 == - 2025. 5. 1 
bool STRING::operator==(const STRING& rhs) const
{
	return std::equal(p.get(), p.get() + num, &rhs.p[0], &rhs.p[rhs.num]);
}

size_t STRING::size() const 
{
	return num;
};

// 2025. 5. 15
STRING_Iterator STRING::begin() const
{
	return STRING_Iterator(&p[0]); // p.get();
}

STRING_Iterator STRING::end() const
{
	return STRING_Iterator(&p[num]); // p.get() + num;
}


// 2025. 5. 19
STRING_Reverse_Iterator STRING::rbegin() const
{
	
	return STRING_Reverse_Iterator(&p[num]);
}

STRING_Reverse_Iterator STRING::rend() const
{
	return STRING_Reverse_Iterator(&p[0]);
}

std::ostream& operator<<(std::ostream& os, const STRING& s)
{
	for (int i = 0; i < s.num; ++i) {
		os << s.p[i];
	}
	return os;
}

std::istream& operator>>(std::istream& is, STRING& s)	// 2025. 4. 14
{
	std::string str;
	is >> str;

	s.num = str.size();
	s.p.release();
	s.p = std::make_unique<char[]>(s.num);
	memcpy(s.p.get(), str.data(), s.num);

	return is;
}

==========================================
저장한 시간: 2025-06-16 오후 7:14:51 월요일
==========================================

//-------------------------------------------------------------------------------------------------
// STRING.h - STL의 동작을 이해하기 위한 class / std::string과 유사하게 작성
//
// 2025. 4. 10 - 시작
// 2025. 4. 14 - 이동의미론(move semantics) 구현
// 2025. 5. 1 - operator==
// 2025. 5. 15 - begin(), end() 제공
// 2025. 5. 19 - rbegin(), rend() 제공 -> class 아니면 안됨
// 2025. 5. 22 - 반복자가 질문에 응답하도록 한다.
// 2025. 5. 22 - begin(), end()가 반복자를 리턴하도록 한다.
// 2025. 5. 26 - sort가능하도록 필요한 연산자를 모두 코딩
//				(C++ 연산자 오버로딩을 잘 이해해야 할 수 있다.)
//-------------------------------------------------------------------------------------------------
#pragma once
#include <iostream>
#include <memory>

// Iterator adaptor - 반복자의 인터페이스를 제공하지만 실제는 다르게 동작
// 표준반복자가 제공해야할 다섯가지 타입을 제공한다.

class STRING_Reverse_Iterator {
public:
	using difference_type = std::ptrdiff_t;
	using value_type = char;
	using pointer = char*;
	using reference = char&;
	using iterator_category = std::random_access_iterator_tag;

public:
	explicit STRING_Reverse_Iterator(char* p) : p{ p } { }; // explicit -> 자동 형변환 막기
	
	// 반복자라면 제공해야할 기본동작이 있다.
	void operator++(){
		--p;
	}

	char operator*() const
	{
		return *(p - 1);
	}

	bool operator==(const STRING_Reverse_Iterator& rhs) const
	{
		return p == rhs.p;
	}
private:
	char* p;
};

class STRING_Iterator
{
public:
	using difference_type = std::ptrdiff_t;
	using value_type = char;
	using pointer = char*;
	using reference = char&;
	using iterator_category = std::random_access_iterator_tag;

public:
	// 2025. 5. 26 special 함수인 default ctor를 요구
	STRING_Iterator() = default;

	STRING_Iterator(char* p) : p{ p } {};

	// 이건 의미를 제대로 코딩해야 한다.
	// 2025. 5. 26 수정 - 자기 자신을 리턴해야한다.
	STRING_Iterator& operator++()
	{
		++p;
		return *this;
	}

	// 2025. 5. 26 수정
	// 원래는 리턴값이 l-value가 아님 -> &를 리턴하고 const를 제거함
	char& operator*()
	{
		return *p;
	}

	// cv-qualifier는 오버로딩으로 구분 가능하다.
	char& operator*() const
	{
		return *p;
	}
	
	// <=> 작성 후 주석처리 -> 우주선 연산의 뭔가뭔가로 다시 살림
	bool operator==(const STRING_Iterator& rhs) const
	{
		return p == rhs.p;
	}

	// sort가 동작하도록 필요 연산자 추가
	// 2025. 5. 26
	difference_type operator-(const STRING_Iterator& rhs) const
	{
		return p - rhs.p;	// 연산의 결과가 클래스의 불변성(invariants)을 해치나 관찰
	}

	STRING_Iterator& operator--()
	{
		--p;
		return *this;
	}

	// 모든 relational operation을 할 수 있게 <=>를 정의해 본다.
	// <, <=, ==, !=, >=, > ==압축=> <=>
	auto operator<=>(const STRING_Iterator& rhs) const
	{
		return p <=> rhs.p;
	}

	STRING_Iterator operator+(difference_type n) const
	{
		return p + n;
	}

	STRING_Iterator operator-(difference_type n) const
	{
		return p - n;
	}

private:
	char* p{}; // = nullptr;
};

class STRING {
public:
	STRING();
	~STRING();
	
	STRING(const char* str);	// 생성자

	// 복사생성자와 복사할당연산자 2025. 4. 10
	STRING(const STRING&);
	STRING& operator=(const STRING&);

	// 이동생성자와 이동할당연산자 2025. 4. 14
	STRING(STRING&&);
	STRING& operator=(STRING&&);

	// 기본정렬을 위한 < 2025. 4. 14
	// 사전식정렬하도록 수정 - 2025. 5. 15
	bool operator<(const STRING&) const;

	// 같은 객체인지 비교 == - 2025. 5. 1 
	bool operator==(const STRING&) const;

	size_t size() const;

	// 2025. 5. 15
	STRING_Iterator begin() const;
	STRING_Iterator end() const;

	// 2025. 5. 19
	STRING_Reverse_Iterator rbegin() const;
	STRING_Reverse_Iterator rend() const;


private:
	size_t num{};
	std::unique_ptr<char[]> p{};

	size_t id;				// 2025. 4. 10 관찰을 위한 객체 고유번호

	friend std::ostream& operator<<(std::ostream&, const STRING&);

	friend std::istream& operator>>(std::istream&, STRING&);	// 2025. 4. 14

	static size_t gid;		// 2025. 4. 10 고유번호 생성
};
